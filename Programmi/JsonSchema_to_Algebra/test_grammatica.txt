{
	allOf[
		if: type(obj), 
		then: if: req["class"], 
		then: oneOf[
			ref: "#/$defs/AS3",
			ref: "#/$defs/ADC"
		], 
		else: ref: "#/$defs/AS3", 
		else: oneOf[
			ref: "#/$defs/AS3_Patch_Body",
			ref: "#/$defs/AS3_Array",
			ref: "#/$defs/ADC_Array"
		],
		properties[
			"declaration"::allOf[
				names: allOf[
					pattern("^[A-Za-z][0-9A-Za-z_]*$"),
					length(null,64)
				],
				type(obj),
				properties[
					"schemaVersion"::allOf[
						type(str),
						enum["3.13.0", "3.12.0", "3.11.0", "3.10.0", "3.9.0", "3.8.0", "3.7.0", "3.6.0", "3.5.0", "3.4.0", "3.3.0", "3.2.0", "3.1.0", "3.0.0"]
					],
					"controls"::allOf[
						type(obj),
						properties[
							"trace"::allOf[
								type(bool)
							],
							"archiveTimestamp"::allOf[
								type(str)
							],
							"logLevel"::allOf[
								type(str),
								enum["emergency", "alert", "critical", "error", "warning", "notice", "info", "debug"]
							],
							"class"::allOf[
								const("[Controls]"),
								type(str)
							],
							"archiveId"::allOf[
								anyOf[
									type(num),
									type(str)
								]
							],
							addp(
							|	trace
							|	archiveTimestamp
							|	logLevel
							|	class
							|	archiveId)::false
						]
					],
					"updateMode"::allOf[
						type(str),
						enum["complete", "selective"]
					],
					"remark"::allOf[
						type(str)
					],
					"scratch"::allOf[
						type(str)
					],
					"id"::allOf[
						type(str)
					],
					"label"::allOf[
						type(str)
					],
					"constants"::allOf[
						names: allOf[
							pattern("^[A-Za-z][0-9A-Za-z_]*$"),
							length(null,64)
						],
						type(obj),
						properties[
							"class"::allOf[
								const("[Constants]"),
								type(str)
							],
							"version"::allOf[
								anyOf[
									type(num),
									type(str)
								]
							],
							"timestamp"::allOf[
								type(str)
							],
							addp(
							|	class
							|	version
							|	timestamp)::allOf[
								if: allOf[
									type(obj),
									req["protected",
										"ciphertext"]
								], 
								then: allOf[
									if: true, 
									then: ref: "#/$defs/JWE",
									properties[
										"allowReuse"::allOf[
											type(bool)
										],
										addp(
										|	allowReuse)::false
									]
								],
								anyOf[
									type(bool),
									type(int),
									type(num),
									type(str),
									type(arr),
									type(obj)
								]
							]
						]
					],
					"class"::allOf[
						const("[ADC]"),
						type(str)
					],
					"target"::allOf[
						type(obj),
						properties[
							"hostname"::allOf[
								type(str)
							],
							"address"::allOf[
								type(str)
							],
							"ssgName"::allOf[
								type(str)
							]
						],
						pro(null,1)
					],
					"Common"::allOf[
						type(obj),
						properties[
							"controls"::ref: "#/$defs/Controls",
							"enable"::allOf[
								const([true]),
								type(bool)
							],
							"remark"::ref: "#/$defs/Remark",
							"label"::ref: "#/$defs/Label",
							"constants"::ref: "#/$defs/Constants",
							"Shared"::ref: "#/$defs/Application_Shared",
							"class"::allOf[
								const("[Tenant]"),
								type(str)
							],
							"verifiers"::allOf[
								type(obj)
							],
							addp(
							|	controls
							|	enable
							|	remark
							|	label
							|	constants
							|	Shared
							|	class
							|	verifiers)::false
						]
					],
					addp(
					|	schemaVersion
					|	controls
					|	updateMode
					|	remark
					|	scratch
					|	id
					|	label
					|	constants
					|	class
					|	target
					|	Common)::ref: "#/$defs/Tenant"
				],
				req["class",
					"schemaVersion",
					"id"]
			]
		]
	],
	def "GSLB_Topology_Record" = {
		allOf[
			not: properties[
				"source"::properties[
					"matchType"::const("[pool]")
				]
			],
			not: properties[
				"source"::properties[
					"matchType"::const("[datacenter]")
				]
			]
		],
		properties[
			"destination"::ref: "#/definitions/GSLB_Topology_Condition",
			"weight"::type(int),
			"source"::ref: "#/definitions/GSLB_Topology_Condition"
		],
		req["source",
			"destination"]
	},
	def "Policy_Action_HTTP_Header" = {
		allOf[
			properties[
				"event"::{
					type(str),
					enum["request", "response"]
				}
			],
			oneOf[
				{
					properties[
						"replace"::{
							type(obj),
							properties[
								"name"::type(str),
								"value"::type(str),
								addp(
								|	name
								|	value)::false
							],
							req["name",
								"value"]
						}
					],
					req["replace"]
				},
				{
					properties[
						"insert"::{
							type(obj),
							properties[
								"name"::type(str),
								"value"::type(str),
								addp(
								|	name
								|	value)::false
							],
							req["name",
								"value"]
						}
					],
					req["insert"]
				},
				{
					properties[
						"remove"::{
							type(obj),
							properties[
								"name"::type(str),
								addp(
								|	name)::false
							],
							req["name"]
						}
					],
					req["remove"]
				}
			]
		],
		type(obj)
	},
	def "Stream_Profile" = {
		type(obj),
		properties[
			"chunkSize"::{
				bet(1024,65535),
				type(int)
			},
			"parentProfile"::ref: "#/definitions/Pointer_Stream_Profile",
			"chunkingEnabled"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"source"::type(str),
			"class"::{
				const("[Stream_Profile]"),
				type(str)
			},
			"target"::type(str),
			addp(
			|	chunkSize
			|	parentProfile
			|	chunkingEnabled
			|	remark
			|	label
			|	source
			|	class
			|	target)::false
		],
		req["class"]
	},
	def "Service_Core" = {
		ref: "#/definitions/Include",
		if: {
			properties[
				"allowVlans"::true
			],
			req["allowVlans"]
		}, 
		then: {
			not: {
				properties[
					"rejectVlans"::true
				],
				req["rejectVlans"]
			}
		},
		type(obj),
		properties[
			"metadata"::ref: "#/definitions/Metadata",
			"policyNAT"::{
				type(obj),
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					},
					addp(
					|	bigip
					|	use)::false
				],
				pro(1,1)
			},
			"profileTrafficLog"::ref: "#/definitions/Pointer_Traffic_Log_Profile",
			"profileDNS"::ref: "#/definitions/Pointer_DNS_Profile",
			"profileSubscriberManagement"::ref: "#/definitions/Pointer_Enforcement_Subscriber_Management_Profile",
			"remark"::ref: "#/definitions/Remark",
			"virtualAddresses"::{
				betitems(1,null),
				uniqueItems,
				type(arr),
				items(;if: type(str), 
				then: , 
				else: if: type(arr), 
				then: {
					betitems(2,2),
					uniqueItems,
					type(arr),
					items(;type(str))
				}, 
				else: {
					type(obj),
					properties[
						"use"::{
							length(1,null),
							type(str)
						}
					],
					pro(1,1)
				})
			},
			"profileRewrite"::ref: "#/definitions/Pointer_Rewrite_Profile",
			"enable"::type(bool),
			"profileDiameterEndpoint"::ref: "#/definitions/Pointer_Enforcement_Diameter_Endpoint_Profile",
			"profileDOS"::ref: "#/definitions/Pointer_DOS_Profile",
			"fallbackPersistenceMethod"::ref: "#/definitions/Basic_Persist",
			"addressStatus"::type(bool),
			"mirroring"::{
				type(str),
				enum["none", "L4"]
			},
			"profileEnforcement"::ref: "#/definitions/Pointer_Enforcement_Profile",
			"maxConnections"::{
				bet(0,null),
				type(int)
			},
			"persistenceMethods"::{
				type(arr),
				items(;ref: "#/definitions/Basic_Persist")
			},
			"lastHop"::if: not: type(obj), 
			then: {
				type(str),
				enum["default", "auto", "disable"]
			}, 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					},
					addp(
					|	bigip
					|	use)::false
				]
			},
			"translateServerPort"::type(bool),
			"allowVlans"::{
				type(arr),
				items(;)
			},
			"translateClientPort"::type(bool),
			"pool"::if: type(str), 
			then: , 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					addp(
					|	bigip)::false
				],
				req["bigip"]
			},
			"policyFirewallEnforced"::ref: "#/definitions/Pointer_Firewall_Policy",
			"iRules"::{
				type(arr),
				items(;if: type(str), 
				then: length(1,null), 
				else: {
					type(obj),
					properties[
						"bigip"::type(str),
						addp(
						|	bigip)::false
					],
					req["bigip"]
				})
			},
			"label"::ref: "#/definitions/Label",
			"clonePools"::ref: "#/definitions/Clone_Pools",
			"rejectVlans"::{
				type(arr),
				items(;)
			},
			"profileIPOther"::ref: "#/definitions/Pointer_IP_Other_Profile",
			"securityLogProfiles"::{
				type(arr),
				items(;{
					type(obj),
					properties[
						"bigip"::type(str),
						"use"::{
							length(1,null),
							type(str)
						},
						addp(
						|	bigip
						|	use)::false
					],
					pro(1,1)
				})
			},
			"policyFirewallStaged"::ref: "#/definitions/Pointer_Firewall_Policy",
			"translateServerAddress"::type(bool),
			"snat"::if: not: type(obj), 
			then: {
				type(str),
				enum["none", "self", "auto"]
			}, 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					},
					addp(
					|	bigip
					|	use)::false
				]
			},
			"profileClassification"::ref: "#/definitions/Pointer_Classification_Profile"
		],
		req["virtualAddresses"]
	},
	def "GSLB_Domain_MX" = ref: "#/definitions/GSLB_Domain",
	def "Enforcement_Interception_Endpoint" = {
		type(obj),
		properties[
			"pool"::ref: "#/definitions/Pointer_Pool",
			"persistence"::{
				type(str),
				enum["destination-ip", "source-ip", "disabled"]
			},
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Enforcement_Interception_Endpoint]"),
				type(str)
			},
			addp(
			|	pool
			|	persistence
			|	label
			|	class)::false
		],
		req["class",
			"pool"]
	},
	def "TLS_Server" = {
		allOf[
			if: {
				properties[
					"c3dEnabled"::const([true])
				],
				req["c3dEnabled"]
			}, 
			then: properties[
				"authenticationMode"::enum["request", "require"]
			],
			if: {
				properties[
					"authenticationMode"::enum["request", "require"]
				],
				req["authenticationMode"]
			}, 
			then: req["authenticationTrustCA"]
		],
		type(obj),
		properties[
			"renegotiationEnabled"::type(bool),
			"ldapStartTLS"::{
				type(str),
				enum["none", "allow", "require"]
			},
			"authenticationTrustCA"::if: type(str), 
			then: length(1,null), 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					addp(
					|	bigip)::false
				],
				req["bigip"]
			},
			"staplerOCSPEnabled"::type(bool),
			"authenticationInviteCA"::if: type(str), 
			then: length(1,null), 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					addp(
					|	bigip)::false
				],
				req["bigip"]
			},
			"allowExpiredCRL"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"c3dEnabled"::type(bool),
			"authenticationFrequency"::{
				type(str),
				enum["one-time", "every-time"]
			},
			"c3dOCSP"::ref: "#/definitions/Pointer_Certificate_Validator_OCSP",
			"certificates"::{
				betitems(1,null),
				type(arr),
				items(;{
					type(obj),
					properties[
						"matchToSNI"::type(str),
						"certificate"::{
							length(1,null),
							type(str)
						},
						addp(
						|	matchToSNI
						|	certificate)::false
					],
					req["certificate"]
				})
			},
			"ciphers"::type(str),
			"class"::{
				const("[TLS_Server]"),
				type(str)
			},
			"requireSNI"::type(bool),
			"authenticationMode"::{
				type(str),
				enum["ignore", "request", "require"]
			},
			"crlFile"::ref: "#/definitions/Pointer_SSL_CRL_File",
			"c3dOCSPUnknownStatusAction"::{
				type(str),
				enum["drop", "ignore"]
			},
			addp(
			|	renegotiationEnabled
			|	ldapStartTLS
			|	authenticationTrustCA
			|	staplerOCSPEnabled
			|	authenticationInviteCA
			|	allowExpiredCRL
			|	remark
			|	label
			|	c3dEnabled
			|	authenticationFrequency
			|	c3dOCSP
			|	certificates
			|	ciphers
			|	class
			|	requireSNI
			|	authenticationMode
			|	crlFile
			|	c3dOCSPUnknownStatusAction)::false
		],
		req["class",
			"certificates"]
	},
	def "GSLB_Monitor_UDP" = properties[
		"receive"::type(str),
		"debugEnabled"::type(bool),
		"probeInterval"::{
			bet(0,null),
			type(int)
		},
		"reverseEnabled"::type(bool),
		"send"::type(str),
		"probeAttempts"::{
			bet(0,null),
			type(int)
		}
	],
	def "GSLB_Monitor" = {
		allOf[
			if: properties[
				"monitorType"::const("[http]")
			], 
			then: ref: "#/definitions/GSLB_Monitor_HTTP",
			if: properties[
				"monitorType"::const("[https]")
			], 
			then: ref: "#/definitions/GSLB_Monitor_HTTPS",
			if: properties[
				"monitorType"::const("[gateway-icmp]")
			], 
			then: ref: "#/definitions/GSLB_Monitor_ICMP",
			if: properties[
				"monitorType"::const("[udp]")
			], 
			then: ref: "#/definitions/GSLB_Monitor_UDP",
			if: properties[
				"monitorType"::const("[tcp]")
			], 
			then: ref: "#/definitions/GSLB_Monitor_TCP"
		],
		type(obj),
		properties[
			"monitorType"::{
				type(str),
				enum["http", "https", "gateway-icmp", "tcp", "udp"]
			},
			"ignoreDownResponseEnabled"::type(bool),
			"probeTimeout"::{
				bet(0,null),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"interval"::{
				bet(0,86399),
				type(int)
			},
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[GSLB_Monitor]"),
				type(str)
			},
			"timeout"::{
				bet(0,86400),
				type(int)
			},
			"transparent"::type(bool),
			"target"::type(str)
		],
		req["class",
			"monitorType"]
	},
	def "Enforcement_Rule_Forwarding_Route_To_Network" = ,
	def "Remark" = type(str),
	def "Enforcement_Profile" = {
		type(obj),
		properties[
			"policiesGlobalLowPrecedence"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Enforcement_Policy")
			},
			"connectionOptimizationEnabled"::type(bool),
			"connectionOptimizationService"::ref: "#/definitions/Pointer_Service",
			"policiesGlobalHighPrecedence"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Enforcement_Policy")
			},
			"parentProfile"::ref: "#/definitions/Pointer_Enforcement_Profile",
			"policiesUnknownSubscribers"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Enforcement_Policy")
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Enforcement_Profile]"),
				type(str)
			},
			addp(
			|	policiesGlobalLowPrecedence
			|	connectionOptimizationEnabled
			|	connectionOptimizationService
			|	policiesGlobalHighPrecedence
			|	parentProfile
			|	policiesUnknownSubscribers
			|	remark
			|	label
			|	class)::false
		],
		req["class"]
	},
	def "NAT_Rule_Destination" = {
		type(obj),
		properties[
			"addressLists"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Firewall_Address_List")
			},
			"portLists"::{
				type(arr),
				items(;{
					type(obj),
					properties[
						"bigip"::type(str),
						"use"::{
							length(1,null),
							type(str)
						},
						addp(
						|	bigip
						|	use)::false
					],
					pro(1,1)
				})
			},
			addp(
			|	addressLists
			|	portLists)::false
		]
	},
	def "DNS_TSIG_Key" = {
		properties[
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"secret"::{
				if: true, 
				then: ref: "#/definitions/Secret",
				type(obj),
				properties[
					"allowReuse"::type(bool)
				]
			},
			"class"::{
				const("[DNS_TSIG_Key]"),
				type(str)
			},
			"algorithm"::{
				type(str),
				enum["hmacmd5", "hmacsha1", "hmacsha256"]
			},
			addp(
			|	remark
			|	label
			|	secret
			|	class
			|	algorithm)::false
		],
		req["class",
			"secret"]
	},
	def "Security_Log_Profile_Protocol_Transfer" = properties[
		"publisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		addp(
		|	publisher)::false
	],
	def "Pointer_Enforcement_Diameter_Endpoint_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_Rewrite_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Capture_Filter" = {
		type(obj),
		properties[
			"clientIps"::{
				betitems(null,10),
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"responseCodes"::{
				betitems(null,10),
				uniqueItems,
				type(arr),
				items(;{
					bet(100,999),
					type(int)
				})
			},
			"responseCapturedParts"::{
				type(str),
				enum["all", "body", "headers", "none"]
			},
			"dosActivity"::{
				type(str),
				enum["any", "mitigated-by-dosl7"]
			},
			"methods"::{
				betitems(null,10),
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"userAgentSubstrings"::{
				betitems(null,10),
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"requestContentFilterSearchPart"::{
				type(str),
				enum["all", "headers", "body", "none", "uri"]
			},
			"capturedProtocols"::{
				type(str),
				enum["all", "http", "https"]
			},
			"requestCapturedParts"::{
				type(str),
				enum["all", "body", "headers", "none"]
			},
			"virtualServers"::{
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"urlPathPrefixes"::{
				betitems(null,10),
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"requestContentFilterSearchString"::type(str),
			"capturedReadyForJsInjection"::{
				type(str),
				enum["disabled", "enabled"]
			},
			"nodeAddresses"::{
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"responseContentFilterSearchString"::type(str),
			"urlFilterType"::{
				type(str),
				enum["all", "black-list", "white-list"]
			},
			"responseContentFilterSearchPart"::{
				type(str),
				enum["all", "body", "headers", "none"]
			}
		]
	},
	def "Security_Log_Profile_Dos_Application" = properties[
		"localPublisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		"remotePublisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		addp(
		|	localPublisher
		|	remotePublisher)::false
	],
	def "Pool" = {
		if: req["monitors"], 
		then: properties[
			"minimumMonitors"::
		],
		type(obj),
		properties[
			"reselectTries"::{
				bet(0,65535),
				type(int)
			},
			"loadBalancingMode"::{
				type(str),
				enum["dynamic-ratio-member", "dynamic-ratio-node", "fastest-app-response", "fastest-node", "least-connections-member", "least-connections-node", "least-sessions", "observed-member", "observed-node", "predictive-member", "predictive-node", "ratio-least-connections-member", "ratio-least-connections-node", "ratio-member", "ratio-node", "ratio-session", "round-robin", "weighted-least-connections-member", "weighted-least-connections-node"]
			},
			"minimumMonitors"::oneOf[
				{
					const("[all]"),
					type(str)
				},
				{
					bet(1,63),
					type(int)
				}
			],
			"members"::{
				type(arr),
				items(;ref: "#/definitions/Pool_Member")
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"minimumMembersActive"::{
				bet(0,65535),
				type(int)
			},
			"class"::{
				const("[Pool]"),
				type(str)
			},
			"monitors"::{
				type(arr),
				items(;ref: "#/definitions/Basic_Monitor")
			},
			"serviceDownAction"::{
				type(str),
				enum["drop", "none", "reselect", "reset"]
			},
			"slowRampTime"::{
				bet(0,900),
				type(int)
			},
			addp(
			|	reselectTries
			|	loadBalancingMode
			|	minimumMonitors
			|	members
			|	remark
			|	label
			|	minimumMembersActive
			|	class
			|	monitors
			|	serviceDownAction
			|	slowRampTime)::false
		],
		req["class"]
	},
	def "DOS_Profile_Application_Bot_Signatures" = {
		type(obj),
		properties[
			"checkingEnabled"::type(bool),
			"disabledSignatures"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Bot_Signature")
			},
			"reportedCategories"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Bot_Signature_Category")
			},
			"blockedCategories"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Bot_Signature_Category")
			},
			addp(
			|	checkingEnabled
			|	disabledSignatures
			|	reportedCategories
			|	blockedCategories)::false
		]
	},
	def "Enforcement_Rule_Forwarding" = {
		allOf[
			if: properties[
				"type"::const("[icap]")
			], 
			then: ref: "#/definitions/Enforcement_Rule_Forwarding_ICAP",
			if: properties[
				"type"::const("[endpoint]")
			], 
			then: ref: "#/definitions/Enforcement_Rule_Forwarding_Endpoint",
			if: properties[
				"type"::const("[route-to-network]")
			], 
			then: ref: "#/definitions/Enforcement_Rule_Forwarding_Route_To_Network",
			if: properties[
				"type"::const("[http]")
			], 
			then: ref: "#/definitions/Enforcement_Rule_Forwarding_HTTP"
		],
		properties[
			"fallbackAction"::{
				type(str),
				enum["continue", "drop"]
			},
			"type"::{
				type(str),
				enum["icap", "endpoint", "route-to-network", "http"]
			}
		],
		req["type"]
	},
	def "WAF_Policy" = {
		oneOf[
			req["url"],
			req["file"]
		],
		type(obj),
		properties[
			"file"::{
				length(3,null),
				type(str)
			},
			"ignoreChanges"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"enforcementMode"::{
				type(str),
				enum["blocking", "transparent"]
			},
			"class"::{
				const("[WAF_Policy]"),
				type(str)
			},
			"url"::{
				length(3,null),
				type(str)
			},
			addp(
			|	file
			|	ignoreChanges
			|	remark
			|	label
			|	enforcementMode
			|	class
			|	url)::false
		],
		req["class"]
	},
	def "Pointer_GSLB_Domain_A" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "DOS_Profile_Application_Detection_IP" = {
		type(obj),
		properties[
			"minimumTps"::{
				bet(0,4294967295),
				type(int)
			},
			"maximumTps"::{
				bet(0,4294967295),
				type(int)
			},
			"minimumAutoTps"::{
				bet(0,4294967295),
				type(int)
			},
			"clientSideDefenseEnabled"::type(bool),
			"tpsIncreaseRate"::{
				bet(0,4294967295),
				type(int)
			},
			"captchaChallengeEnabled"::type(bool),
			"rateLimitingEnabled"::type(bool),
			"maximumAutoTps"::{
				bet(0,4294967295),
				type(int)
			},
			"rateLimitingMode"::{
				type(str),
				enum["rate-limit", "block-all"]
			},
			addp(
			|	minimumTps
			|	maximumTps
			|	minimumAutoTps
			|	clientSideDefenseEnabled
			|	tpsIncreaseRate
			|	captchaChallengeEnabled
			|	rateLimitingEnabled
			|	maximumAutoTps
			|	rateLimitingMode)::false
		]
	},
	def "Policy_Compare_Number" = {
		type(obj),
		properties[
			"values"::{
				betitems(1,null),
				type(arr),
				items(;type(int))
			},
			"operand"::{
				type(str),
				enum["equals", "less", "greater", "less-or-equal", "greater-or-equal"]
			},
			addp(
			|	values
			|	operand)::false
		],
		req["values"]
	},
	def "GSLB_Pool_CNAME" = ref: "#/definitions/GSLB_Pool",
	def "DOS_Profile_Network_Dynamic_Signatures" = {
		type(obj),
		properties[
			"detectionMode"::{
				type(str),
				enum["disabled", "learn-only", "enabled"]
			},
			"mitigationMode"::{
				type(str),
				enum["none", "low", "medium", "high"]
			},
			"scrubbingDuration"::{
				bet(60,4294967295),
				type(int)
			},
			"scrubbingCategory"::ref: "#/definitions/Pointer_Blacklist_Category",
			"scrubbingEnabled"::type(bool),
			addp(
			|	detectionMode
			|	mitigationMode
			|	scrubbingDuration
			|	scrubbingCategory
			|	scrubbingEnabled)::false
		]
	},
	def "Enum_Country_Analytics" = {
		type(str),
		enum["Afghanistan", "Aland Islands", "Albania", "Algeria", "American Samoa", "Andorra", "Angola", "Anguilla", "Anonymous Proxy", "Antarctica", "Antigua and Barbuda", "Argentina", "Armenia", "Aruba", "Asia/Pacific Region", "Australia", "Austria", "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belarus", "Belgium", "Belize", "Benin", "Bermuda", "Bhutan", "Bolivia", "Bonaire, Saint Eustatius and Saba", "Bosnia and Herzegovina", "Botswana", "Bouvet Island", "Brazil", "British Indian Ocean Territory", "Brunei Darussalam", "Bulgaria", "Burkina Faso", "Burundi", "Cambodia", "Cameroon", "Canada", "Cape Verde", "Cayman Islands", "Central African Republic", "Chad", "Chile", "China", "Christmas Island", "Cocos (Keeling) Islands", "Colombia", "Comoros", "Congo", "Congo, The Democratic Republic of the", "Cook Islands", "Costa Rica", "Cote D'Ivoire", "Croatia", "Cuba", "Cyprus", "Czech Republic", "Denmark", "Djibouti", "Dominica", "Dominican Republic", "Ecuador", "Egypt", "El Salvador", "Equatorial Guinea", "Eritrea", "Estonia", "Ethiopia", "Europe", "Falkland Islands (Malvinas)", "Faroe Islands", "Fiji", "Finland", "France", "France, Metropolitan", "French Guiana", "French Polynesia", "French Southern Territories", "Gabon", "Gambia", "Georgia", "Germany", "Ghana", "Gibraltar", "Greece", "Greenland", "Grenada", "Guadeloupe", "Guam", "Guatemala", "Guernsey", "Guinea", "Guinea-Bissau", "Guyana", "Haiti", "Heard Island and McDonald Islands", "Holy See (Vatican City State)", "Honduras", "Hong Kong", "Hungary", "Iceland", "India", "Indonesia", "Iran, Islamic Republic of", "Iraq", "Ireland", "Isle of Man", "Israel", "Italy", "Jamaica", "Japan", "Jersey", "Jordan", "Kazakhstan", "Kenya", "Kiribati", "Korea, Democratic People's Republic of", "Korea, Republic of", "Kuwait", "Kyrgyzstan", "Lao People's Democratic Republic", "Latvia", "Lebanon", "Lesotho", "Liberia", "Libyan Arab Jamahiriya", "Liechtenstein", "Lithuania", "Luxembourg", "Macau", "Macedonia", "Madagascar", "Malawi", "Malaysia", "Maldives", "Mali", "Malta", "Marshall Islands", "Martinique", "Mauritania", "Mauritius", "Mayotte", "Mexico", "Micronesia, Federated States of", "Moldova, Republic of", "Monaco", "Mongolia", "Montenegro", "Montserrat", "Morocco", "Mozambique", "Myanmar", "Namibia", "Nauru", "Nepal", "Netherlands", "Netherlands Antilles", "New Caledonia", "New Zealand", "Nicaragua", "Niger", "Nigeria", "Niue", "Norfolk Island", "Northern Mariana Islands", "Norway", "Oman", "Other", "Pakistan", "Palau", "Palestinian Territory", "Panama", "Papua New Guinea", "Paraguay", "Peru", "Philippines", "Pitcairn Islands", "Poland", "Portugal", "Puerto Rico", "Qatar", "Reunion", "Romania", "Russian Federation", "Rwanda", "Saint Barthelemy", "Saint Helena", "Saint Kitts and Nevis", "Saint Lucia", "Saint Martin", "Saint Pierre and Miquelon", "Saint Vincent and the Grenadines", "Samoa", "San Marino", "Sao Tome and Principe", "Satellite Provider", "Saudi Arabia", "Senegal", "Serbia", "Seychelles", "Sierra Leone", "Singapore", "Slovakia", "Slovenia", "Solomon Islands", "Somalia", "South Africa", "South Georgia and the South Sandwich Islands", "Spain", "Sri Lanka", "Sudan", "Suriname", "Svalbard and Jan Mayen", "Swaziland", "Sweden", "Switzerland", "Syrian Arab Republic", "Taiwan", "Tajikistan", "Tanzania, United Republic of", "Thailand", "Timor-Leste", "Togo", "Tokelau", "Tonga", "Trinidad and Tobago", "Tunisia", "Turkey", "Turkmenistan", "Turks and Caicos Islands", "Tuvalu", "Uganda", "Ukraine", "United Arab Emirates", "United Kingdom", "United States", "United States Minor Outlying Islands", "Unknown", "Uruguay", "Uzbekistan", "Vanuatu", "Venezuela", "Vietnam", "Virgin Islands, British", "Virgin Islands, U.S.", "Wallis and Futuna", "Western Sahara", "Yemen", "Zambia", "Zimbabwe"]
	},
	def "Enforcement_Rule_Usage_Reporting" = {
		allOf[
			if: properties[
				"destination"::const("[gx]")
			], 
			then: ref: "#/definitions/Enforcement_Rule_Usage_Gx",
			if: properties[
				"destination"::const("[sd]")
			], 
			then: ref: "#/definitions/Enforcement_Rule_Usage_Sd",
			if: properties[
				"destination"::const("[hsl]")
			], 
			then: ref: "#/definitions/Enforcement_Rule_Usage_Hsl",
			if: properties[
				"destination"::const("[radius-accounting]")
			], 
			then: ref: "#/definitions/Enforcement_Rule_Usage_Radius",
			if: properties[
				"destination"::enum["gx", "sd", "radius-accounting"]
			], 
			then: properties[
				"granularity"::const("[session]")
			],
			if: properties[
				"destination"::enum["gx", "sd"]
			], 
			then: properties[
				"interval"::const([0])
			],
			if: properties[
				"granularity"::enum["flow", "session"],
				"destination"::enum["hsl", "radius-accounting"]
			], 
			then: anyOf[
				{
					properties[
						"interval"::bet(1,null)
					],
					req["interval"]
				},
				req["volume"]
			],
			if: properties[
				"granularity"::const("[transaction]"),
				"destination"::const("[hsl]")
			], 
			then: properties[
				"interval"::const([0])
			]
		],
		properties[
			"volume"::ref: "#/definitions/Enforcement_Rule_Usage_Reporting_Volume",
			"granularity"::{
				type(str),
				enum["flow", "session", "transaction"]
			},
			"destination"::{
				type(str),
				enum["gx", "sd", "hsl", "radius-accounting"]
			},
			"interval"::{
				bet(0,null),
				type(int)
			},
			"transaction"::ref: "#/definitions/Enforcement_Rule_Usage_Reporting_Transaction"
		],
		req["destination"]
	},
	def "Pointer_Firewall_Rule_List" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Endpoint_Policy_Rule" = {
		type(obj),
		properties[
			"name"::type(str),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"conditions"::{
				type(arr),
				items(;ref: "#/definitions/Policy_Condition")
			},
			"actions"::{
				type(arr),
				items(;ref: "#/definitions/Policy_Action")
			},
			addp(
			|	name
			|	remark
			|	label
			|	conditions
			|	actions)::false
		],
		req["name"]
	},
	def "Pointer_SIP_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Enum_ISP" = {
		type(str),
		enum["AOL", "BeijingCNC", "ChinaEducationNetwork", "ChinaMobilNetwork", "ChinaRailwayTelcom", "ChinaTelecom", "ChinaUnicom", "CNC", "Comcast", "Earthlink", "ShanghaiCNC", "ShanghaiTelecom"]
	},
	def "DOS_Profile_Application_Detection_Geolocation" = {
		type(obj),
		properties[
			"minimumAutoTps"::{
				bet(0,4294967295),
				type(int)
			},
			"clientSideDefenseEnabled"::type(bool),
			"captchaChallengeEnabled"::type(bool),
			"shareIncreaseRate"::{
				bet(0,4294967295),
				type(int)
			},
			"rateLimitingEnabled"::type(bool),
			"minimumShare"::{
				bet(0,4294967295),
				type(int)
			},
			"maximumAutoTps"::{
				bet(0,4294967295),
				type(int)
			},
			"rateLimitingMode"::{
				type(str),
				enum["rate-limit", "block-all"]
			},
			addp(
			|	minimumAutoTps
			|	clientSideDefenseEnabled
			|	captchaChallengeEnabled
			|	shareIncreaseRate
			|	rateLimitingEnabled
			|	minimumShare
			|	maximumAutoTps
			|	rateLimitingMode)::false
		]
	},
	def "Enforcement_Rule_Forwarding_ICAP" = {
		properties[
			"icapService"::ref: "#/definitions/Pointer_Service",
			"icapType"::{
				type(str),
				enum["request", "response", "both"]
			}
		],
		req["icapType",
			"icapService"]
	},
	def "DNS_Cache_Transparent" = properties[
		"localZones"::{
			names: ,
			type(obj),
			properties[
				addp()::ref: "#/definitions/DNS_Zone_Local"
			]
		},
		"recordCacheSize"::{
			bet(1,4294967295),
			type(int)
		},
		"messageCacheSize"::{
			bet(0,4294967295),
			type(int)
		},
		"answerDefaultZones"::type(bool),
		"recordRotationMethod"::{
			type(str),
			enum["none", "query-id"]
		}
	],
	def "Security_Log_Profile_Protocol_Sip_Dos" = properties[
		"publisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		addp(
		|	publisher)::false
	],
	def "AS3" = {
		type(obj),
		properties[
			"targetHost"::type(str),
			"targetUsername"::{
				pattern("^[^:]*$"),
				length(null,254),
				type(str)
			},
			"redeployUpdateMode"::{
				type(str),
				enum["original", "complete", "selective"]
			},
			"targetPassphrase"::{
				length(null,254),
				type(str)
			},
			"syncToGroup"::type(str),
			"retrieveAge"::oneOf[
				{
					bet(0,null),
					type(int)
				},
				{
					const("[list]"),
					type(str)
				}
			],
			"targetPort"::{
				bet(0,65535),
				type(int)
			},
			"declaration"::ref: "#/definitions/ADC",
			"trace"::type(bool),
			"targetTimeout"::{
				bet(1,900),
				type(int)
			},
			"logLevel"::{
				type(str),
				enum["emergency", "alert", "critical", "error", "warning", "notice", "info", "debug"]
			},
			"patchBody"::ref: "#/definitions/AS3_Patch_Body",
			"action"::{
				type(str),
				enum["deploy", "dry-run", "patch", "redeploy", "retrieve", "remove"]
			},
			"redeployAge"::{
				bet(0,15),
				type(int)
			},
			"targetTokens"::{
				type(obj),
				properties[
					"^[^\x00-\x20:\x7f-\xff]{1,254}$"::{
						pattern("^[^\x00-\x1f\x7f-\xff]*$"),
						length(null,8192),
						type(str)
					},
					addp(
					|	"^[^\x00-\x20:\x7f-\xff]{1,254}$")::false
				]
			},
			"persist"::type(bool),
			"historyLimit"::{
				bet(2,15),
				type(num)
			},
			"resourceTimeout"::{
				bet(1,900),
				type(int)
			},
			"class"::{
				type(str),
				enum["AS3"]
			}
		],
		req["class"]
	},
	def "Basic_Persist" = if: type(str), 
	then: enum["cookie", "destination-address", "msrdp", "source-address", "tls-session-id"], 
	else: {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		]
	},
	def "Policy_Action_HTTP" = {
		type(obj),
		properties[
			"event"::{
				type(str),
				enum["client-accepted", "proxy-request", "request", "response", "server-connected"]
			},
			"enabled"::type(bool)
		]
	},
	def "Security_Log_Profile_Protocol_Dns" = properties[
		"logDroppedRequests"::type(bool),
		"logMalformedRequests"::type(bool),
		"logRejectedRequests"::type(bool),
		"storageFormat"::anyOf[
			{
				length(1,null),
				type(str)
			},
			{
				type(obj),
				properties[
					"delimiter"::type(str),
					"fields"::{
						type(arr),
						items(;{
							type(str),
							enum["action", "attack-type", "context-name", "date-time", "dest-ip", "dest-port", "dns-query-name", "dns-query-type", "src-ip", "src-port", "vlan", "route-domain"]
						})
					},
					addp(
					|	delimiter
					|	fields)::false
				],
				req["fields"]
			}
		],
		"publisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		"logMaliciousRequests"::type(bool),
		"logFilteredDroppedRequests"::type(bool),
		addp(
		|	logDroppedRequests
		|	logMalformedRequests
		|	logRejectedRequests
		|	storageFormat
		|	publisher
		|	logMaliciousRequests
		|	logFilteredDroppedRequests)::false
	],
	def "Pointer_Classification_Preset" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Enforcement_Diameter_Endpoint_Profile" = {
		type(obj),
		properties[
			"originHost"::type(str),
			"label"::ref: "#/definitions/Label",
			"fatalGraceTime"::{
				bet(0,null),
				type(int)
			},
			"messageRetransmitDelay"::{
				bet(0,null),
				type(int)
			},
			"productName"::type(str),
			"messageMaxRetransmits"::{
				bet(0,null),
				type(int)
			},
			"parentProfile"::ref: "#/definitions/Pointer_Enforcement_Diameter_Endpoint_Profile",
			"originRealm"::type(str),
			"protocolProfileGx"::ref: "#/definitions/Pointer_Enforcement_Profile_Gx",
			"destinationRealm"::type(str),
			"supportedApps"::{
				betitems(1,null),
				uniqueItems,
				type(arr),
				items(;{
					type(str),
					enum["Gx", "Gy", "Sd"]
				})
			},
			"class"::{
				const("[Enforcement_Diameter_Endpoint_Profile]"),
				type(str)
			},
			"destinationHost"::type(str),
			addp(
			|	originHost
			|	label
			|	fatalGraceTime
			|	messageRetransmitDelay
			|	productName
			|	messageMaxRetransmits
			|	parentProfile
			|	originRealm
			|	protocolProfileGx
			|	destinationRealm
			|	supportedApps
			|	class
			|	destinationHost)::false
		],
		req["class",
			"supportedApps"]
	},
	def "Metadata" = {
		type(obj),
		properties[
			addp()::{
				type(obj),
				properties[
					"persist"::type(bool),
					"value"::type(str),
					addp(
					|	persist
					|	value)::false
				],
				req["value"]
			}
		]
	},
	def "Policy_Action_HTTP_Cookie" = {
		allOf[
			properties[
				"event"::{
					type(str),
					enum["request"]
				}
			],
			oneOf[
				{
					properties[
						"insert"::{
							type(obj),
							properties[
								"name"::type(str),
								"value"::type(str),
								addp(
								|	name
								|	value)::false
							],
							req["name",
								"value"]
						}
					],
					req["insert"]
				},
				{
					properties[
						"remove"::{
							type(obj),
							properties[
								"name"::type(str),
								addp(
								|	name)::false
							],
							req["name"]
						}
					],
					req["remove"]
				}
			]
		],
		type(obj)
	},
	def "Endpoint_Policy" = {
		type(obj),
		properties[
			"remark"::ref: "#/definitions/Remark",
			"rules"::{
				type(arr),
				items(;ref: "#/definitions/Endpoint_Policy_Rule")
			},
			"label"::ref: "#/definitions/Label",
			"strategy"::{
				type(str),
				enum["all-match", "best-match", "first-match", "custom"]
			},
			"class"::{
				const("[Endpoint_Policy]"),
				type(str)
			},
			"customStrategy"::if: type(str), 
			then: length(1,null), 
			else: {
				type(obj),
				properties[
					"bigip"::type(str)
				],
				req["bigip"]
			},
			addp(
			|	remark
			|	rules
			|	label
			|	strategy
			|	class
			|	customStrategy)::false
		],
		req["class"]
	},
	def "Pointer_ILX_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Enforcement_Rule" = {
		type(obj),
		properties[
			"dscpMarkingDownlink"::if: type(str), 
			then: const("[pass-through]"), 
			else: {
				bet(0,63),
				type(int)
			},
			"l2MarkingUplink"::if: type(str), 
			then: const("[pass-through]"), 
			else: {
				bet(0,7),
				type(int)
			},
			"tcpOptimizationUplink"::ref: "#/definitions/Pointer_TCP_Profile",
			"classificationFilters"::{
				type(arr),
				items(;ref: "#/definitions/Enforcement_Rule_Classification_Filter")
			},
			"flowInfoFilters"::{
				type(arr),
				items(;ref: "#/definitions/Enforcement_Rule_Flow_Filter")
			},
			"modifyHttpHeader"::ref: "#/definitions/Enforcement_Rule_Modify_HTTP_Header",
			"forwarding"::ref: "#/definitions/Enforcement_Rule_Forwarding",
			"gateStatusEnabled"::type(bool),
			"precedence"::{
				bet(1,4294967295),
				type(int)
			},
			"tclFilter"::type(str),
			"qoeReporting"::ref: "#/definitions/Enforcement_Rule_Report_Destination_HSL",
			"quota"::ref: "#/definitions/Enforcement_Rule_Quota",
			"qosBandwidthControllerUplink"::ref: "#/definitions/Enforcement_Rule_QOS",
			"usageReporting"::ref: "#/definitions/Enforcement_Rule_Usage_Reporting",
			"l2MarkingDownlink"::if: type(str), 
			then: const("[pass-through]"), 
			else: {
				bet(0,7),
				type(int)
			},
			"DTOSTethering"::ref: "#/definitions/Enforcement_Rule_DTOS_Tethering",
			"serviceChain"::ref: "#/definitions/Pointer_Enforcement_Service_Chain_Endpoint",
			"iRule"::ref: "#/definitions/Pointer_Enforcement_iRule",
			"dscpMarkingUplink"::if: type(str), 
			then: const("[pass-through]"), 
			else: {
				bet(0,63),
				type(int)
			},
			"tcpAnalyticsEnabled"::type(bool),
			"urlCategorizationFilters"::{
				type(arr),
				items(;ref: "#/definitions/Enforcement_Rule_URL_Categorization_Filter")
			},
			"name"::type(str),
			"insertContent"::ref: "#/definitions/Enforcement_Rule_Insert_Content",
			"tcpOptimizationDownlink"::ref: "#/definitions/Pointer_TCP_Profile",
			"interceptionEndpoint"::ref: "#/definitions/Pointer_Enforcement_Interception_Endpoint",
			"qosBandwidthControllerDownlink"::ref: "#/definitions/Enforcement_Rule_QOS",
			"ranCongestion"::ref: "#/definitions/Enforcement_Rule_Ran_Congestion",
			addp(
			|	dscpMarkingDownlink
			|	l2MarkingUplink
			|	tcpOptimizationUplink
			|	classificationFilters
			|	flowInfoFilters
			|	modifyHttpHeader
			|	forwarding
			|	gateStatusEnabled
			|	precedence
			|	tclFilter
			|	qoeReporting
			|	quota
			|	qosBandwidthControllerUplink
			|	usageReporting
			|	l2MarkingDownlink
			|	DTOSTethering
			|	serviceChain
			|	iRule
			|	dscpMarkingUplink
			|	tcpAnalyticsEnabled
			|	urlCategorizationFilters
			|	name
			|	insertContent
			|	tcpOptimizationDownlink
			|	interceptionEndpoint
			|	qosBandwidthControllerDownlink
			|	ranCongestion)::false
		],
		req["name",
			"precedence"]
	},
	def "Service_TCP_Core" = {
		if: true, 
		then: ref: "#/definitions/Service_Core",
		type(obj),
		properties[
			"policyEndpoint"::if: type(arr), 
			then: items(;ref: "#/definitions/Pointer_Endpoint_Policy"), 
			else: ref: "#/definitions/Pointer_Endpoint_Policy",
			"clientTLS"::if: type(str), 
			then: length(1,null), 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					addp(
					|	bigip)::false
				],
				req["bigip"]
			},
			"profileStream"::ref: "#/definitions/Pointer_Stream_Profile",
			"serverTLS"::if: type(str), 
			then: length(1,null), 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					addp(
					|	bigip)::false
				],
				req["bigip"]
			},
			"layer4"::{
				const("[tcp]"),
				type(str)
			},
			"profileFIX"::ref: "#/definitions/Pointer_FIX_Profile",
			"profileSSHProxy"::ref: "#/definitions/Pointer_SSH_Proxy_Profile",
			"virtualPort"::{
				bet(0,65535),
				type(int)
			},
			"profileTCP"::if: not: type(obj), 
			then: {
				type(str),
				enum["normal", "lan", "wan", "mobile"]
			}, 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					"ingress"::if: not: type(obj), 
					then: {
						type(str),
						enum["normal", "lan", "wan", "mobile"]
					}, 
					else: {
						type(obj),
						properties[
							"bigip"::type(str),
							"use"::{
								length(1,null),
								type(str)
							},
							addp(
							|	bigip
							|	use)::false
						],
						pro(1,1)
					},
					"use"::{
						length(1,null),
						type(str)
					},
					"egress"::if: not: type(obj), 
					then: {
						type(str),
						enum["normal", "lan", "wan", "mobile"]
					}, 
					else: {
						type(obj),
						properties[
							"bigip"::type(str),
							"use"::{
								length(1,null),
								type(str)
							},
							addp(
							|	bigip
							|	use)::false
						],
						pro(1,1)
					},
					addp(
					|	bigip
					|	ingress
					|	use
					|	egress)::false
				]
			}
		]
	},
	def "NAT_Rule" = {
		type(obj),
		properties[
			"protocol"::{
				type(str),
				enum["any", "tcp", "udp"]
			},
			"name"::type(str),
			"destination"::ref: "#/definitions/NAT_Rule_Destination",
			"sourceTranslation"::{
				type(obj),
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					},
					addp(
					|	bigip
					|	use)::false
				],
				pro(1,1)
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"source"::ref: "#/definitions/NAT_Rule_Source",
			addp(
			|	protocol
			|	name
			|	destination
			|	sourceTranslation
			|	remark
			|	label
			|	source)::false
		],
		req["name"]
	},
	def "Security_Log_Profile_Network" = properties[
		"logTcpEvents"::type(bool),
		"logTranslationFields"::type(bool),
		"logRuleMatchRejects"::type(bool),
		"rateLimitTcpEvents"::type(int),
		"rateLimitIpErrors"::type(int),
		"storageFormat"::anyOf[
			{
				length(1,null),
				type(str)
			},
			{
				type(obj),
				properties[
					"delimiter"::type(str),
					"fields"::{
						type(arr),
						items(;{
							type(str),
							enum["acl-policy-name", "acl-policy-type", "acl-rule-name", "action", "bigip-hostname", "context-name", "context-type", "date-time", "dest-ip", "dest-port", "drop-reason", "management-ip-address", "protocol", "route-domain", "sa-translation-pool", "sa-translation-type", "src-ip", "src-port", "translated-dest-ip", "translated-dest-port", "translated-ip-protocol", "translated-route-domain", "translated-src-ip", "translated-src-port", "translated-vlan", "vlan"]
						})
					},
					addp(
					|	delimiter
					|	fields)::false
				],
				req["fields"]
			}
		],
		"rateLimitAggregate"::type(int),
		"logTcpErrors"::type(bool),
		"alwaysLogRegion"::type(bool),
		"rateLimitRuleMatchAccepts"::type(int),
		"rateLimitRuleMatchRejects"::type(int),
		"logIpErrors"::type(bool),
		"logRuleMatchAccepts"::type(bool),
		"rateLimitRuleMatchDrops"::type(int),
		"logRuleMatchDrops"::type(bool),
		"rateLimitTcpErrors"::type(int),
		"publisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		addp(
		|	logTcpEvents
		|	logTranslationFields
		|	logRuleMatchRejects
		|	rateLimitTcpEvents
		|	rateLimitIpErrors
		|	storageFormat
		|	rateLimitAggregate
		|	logTcpErrors
		|	alwaysLogRegion
		|	rateLimitRuleMatchAccepts
		|	rateLimitRuleMatchRejects
		|	logIpErrors
		|	logRuleMatchAccepts
		|	rateLimitRuleMatchDrops
		|	logRuleMatchDrops
		|	rateLimitTcpErrors
		|	publisher)::false
	],
	def "GSLB_Pool_Member_AAAA" = {
		type(obj),
		properties[
			"server"::ref: "#/definitions/Pointer_GSLB_Server",
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"virtualServer"::type(str),
			"ratio"::{
				bet(0,65535),
				type(int)
			},
			addp(
			|	server
			|	remark
			|	label
			|	virtualServer
			|	ratio)::false
		],
		req["server",
			"virtualServer"]
	},
	def "Monitor_TCP_Half_Open" = properties[
		"transparent"::type(bool)
	],
	def "Pointer_Log_Destination" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Policy_Condition" = {
		allOf[
			if: properties[
				"type"::const("[httpUri]")
			], 
			then: ref: "#/definitions/Policy_Condition_HTTP_URI",
			if: properties[
				"type"::const("[httpHeader]")
			], 
			then: ref: "#/definitions/Policy_Condition_HTTP_Header",
			if: properties[
				"type"::const("[httpCookie]")
			], 
			then: ref: "#/definitions/Policy_Condition_HTTP_Cookie",
			if: properties[
				"type"::const("[sslExtension]")
			], 
			then: ref: "#/definitions/Policy_Condition_SSL_Extension"
		],
		type(obj),
		properties[
			"type"::{
				type(str),
				enum["httpHeader", "httpUri", "httpCookie", "sslExtension"]
			}
		],
		req["type"]
	},
	def "Policy_Compare_String" = {
		type(obj),
		properties[
			"caseSensitive"::type(bool),
			"values"::{
				betitems(1,null),
				type(arr),
				items(;type(str))
			},
			"operand"::{
				type(str),
				enum["equals", "starts-with", "ends-with", "contains"]
			},
			addp(
			|	caseSensitive
			|	values
			|	operand)::false
		],
		req["values"]
	},
	def "HTTP_Profile_Transparent" = {
		type(obj),
		properties[
			"truncatedRedirects"::type(bool),
			"maxHeaderCount"::{
				bet(1,1024),
				type(int)
			},
			"oversizeClientHeaders"::{
				type(str),
				enum["pass-through", "reject"]
			},
			"oversizeServerHeaders"::{
				type(str),
				enum["pass-through", "reject"]
			},
			"excessClientHeaders"::{
				type(str),
				enum["pass-through", "reject"]
			},
			"excessServerHeaders"::{
				type(str),
				enum["pass-through", "reject"]
			},
			"maxHeaderSize"::{
				bet(9,262144),
				type(int)
			}
		]
	},
	def "GSLB_Monitor_TCP" = properties[
		"receive"::type(str),
		"reverseEnabled"::type(bool),
		"send"::type(str)
	],
	def "Pointer_Endpoint_Policy" = if: type(str), 
	then: length(1,null), 
	else: {
		type(obj),
		properties[
			"bigip"::type(str)
		],
		req["bigip"]
	},
	def "Pointer_Bot_Signature" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Pointer_SSL_Certificate" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Monitor_External" = {
		oneOf[
			req["pathname"],
			req["script"]
		],
		properties[
			"expand"::type(bool),
			"arguments"::type(str),
			"script"::if: true, 
			then: ref: "#/definitions/F5string",
			"pathname"::{
				length(2,null),
				type(str)
			}
		]
	},
	def "Enforcement_Rule_URL_Categorization_Filter" = {
		properties[
			"name"::type(str),
			"category"::ref: "#/definitions/Pointer_Classification_Category",
			"invertMatch"::type(bool),
			addp(
			|	name
			|	category
			|	invertMatch)::false
		],
		req["name",
			"category"]
	},
	def "GSLB_Prober_Pool_Member" = {
		type(obj),
		properties[
			"memberOrder"::{
				bet(0,65535),
				type(int)
			},
			"enabled"::type(bool)
		]
	},
	def "Monitor_Send_Recv" = {
		if: true, 
		then: ref: "#/definitions/Monitor_May_Adapt",
		properties[
			"receive"::type(str),
			"reverse"::type(bool),
			"send"::type(str),
			"receiveDown"::type(str),
			"transparent"::type(bool)
		],
		req["send",
			"receive"]
	},
	def "Enforcement_Subscriber_Management_Profile_DHCP" = {
		type(obj),
		properties[
			"service"::ref: "#/definitions/Pointer_Service",
			"enabled"::type(bool),
			addp(
			|	service
			|	enabled)::false
		],
		req["service"]
	},
	def "Firewall_Rule_Destination" = {
		type(obj),
		properties[
			"addressLists"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Firewall_Address_List")
			},
			"portLists"::{
				type(arr),
				items(;{
					type(obj),
					properties[
						"bigip"::type(str),
						"use"::{
							length(1,null),
							type(str)
						},
						addp(
						|	bigip
						|	use)::false
					],
					pro(1,1)
				})
			},
			addp(
			|	addressLists
			|	portLists)::false
		]
	},
	def "Traffic_Log_Profile_Response_Settings" = {
		type(obj),
		properties[
			"responseErrorLoggingEnabled"::type(bool),
			"byDefaultEnabled"::type(bool),
			"responseProtocol"::{
				type(str),
				enum["mds-tcp", "mds-udp"]
			},
			"responseTemplate"::type(str),
			"responseErrorTemplate"::type(str),
			"responseErrorPool"::ref: "#/definitions/Pointer_Pool",
			"responsePool"::ref: "#/definitions/Pointer_Pool",
			"responseErrorProtocol"::{
				type(str),
				enum["mds-tcp", "mds-udp"]
			},
			"responseEnabled"::type(bool),
			addp(
			|	responseErrorLoggingEnabled
			|	byDefaultEnabled
			|	responseProtocol
			|	responseTemplate
			|	responseErrorTemplate
			|	responseErrorPool
			|	responsePool
			|	responseErrorProtocol
			|	responseEnabled)::false
		]
	},
	def "Service_UDP_Core" = {
		if: true, 
		then: ref: "#/definitions/Service_Core",
		type(obj),
		properties[
			"policyEndpoint"::if: type(arr), 
			then: items(;ref: "#/definitions/Pointer_Endpoint_Policy"), 
			else: ref: "#/definitions/Pointer_Endpoint_Policy",
			"clientTLS"::if: type(str), 
			then: length(1,null), 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					addp(
					|	bigip)::false
				],
				req["bigip"]
			},
			"serverTLS"::if: type(str), 
			then: length(1,null), 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					addp(
					|	bigip)::false
				],
				req["bigip"]
			},
			"layer4"::{
				const("[udp]"),
				type(str)
			},
			"profileRADIUS"::ref: "#/definitions/Pointer_Radius_Profile",
			"virtualPort"::{
				bet(0,65535),
				type(int)
			},
			"profileUDP"::if: not: type(obj), 
			then: {
				type(str),
				enum["normal"]
			}, 
			else: {
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					},
					addp(
					|	bigip
					|	use)::false
				],
				pro(1,1)
			}
		]
	},
	def "AS3_Patch_Item" = {
		type(obj),
		properties[
			"op"::type(str),
			"path"::type(str),
			"value"::,
			"target"::{
				type(obj),
				properties[
					"hostname"::type(str),
					"address"::type(str),
					"ssgName"::type(str)
				],
				pro(null,1)
			}
		],
		req["op",
			"path"]
	},
	def "Enforcement_Rule_Forwarding_HTTP" = {
		properties[
			"redirectUrl"::type(str)
		],
		req["redirectUrl"]
	},
	def "Pointer_FIX_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "ADC" = {
		type(obj),
		properties[
			"class"::{
				const("[ADC]"),
				type(str)
			}
		],
		req["class"]
	},
	def "Pointer_DNS_Nameserver" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Enforcement_Rule_Insert_Content" = properties[
		"duration"::{
			bet(1,4294967295),
			type(int)
		},
		"valueType"::{
			type(str),
			enum["string", "tcl-snippet"]
		},
		"valueContent"::type(str),
		"position"::{
			type(str),
			enum["append", "prepend"]
		},
		"tagName"::type(str),
		"frequency"::{
			type(str),
			enum["always", "once", "once-every"]
		},
		addp(
		|	duration
		|	valueType
		|	valueContent
		|	position
		|	tagName
		|	frequency)::false
	],
	def "Label" = type(str),
	def "Service_UDP" = {
		if: true, 
		then: ref: "#/definitions/Service_UDP_Core",
		type(obj),
		properties[
			"persistenceMethods"::{
				type(arr),
				items(;ref: "#/definitions/Basic_Persist")
			},
			"class"::{
				const("[Service_UDP]"),
				type(str)
			}
		],
		req["class",
			"virtualPort"]
	},
	def "Pointer_GSLB_Pool_AAAA" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_GSLB_Domain_AAAA" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "GSLB_Monitor_ICMP" = properties[
		"probeInterval"::{
			bet(0,null),
			type(int)
		},
		"probeAttempts"::{
			bet(0,null),
			type(int)
		}
	],
	def "Data_Group_Records_Integer" = allOf[
		ref: "#/definitions/Data_Group_Records_Base"
	],
	def "Pool_Member" = {
		allOf[
			if: req["bigip"], 
			then: if: req["monitors"], 
			then: properties[
				"minimumMonitors"::
			],
			if: {
				properties[
					"addressDiscovery"::enum["fqdn", "aws", "azure", "gce", "consul"]
				],
				req["addressDiscovery"]
			}, 
			then: {
				not: req["bigip"],
				properties[
					"updateInterval"::{
						bet(1,3600),
						type(int)
					}
				]
			},
			if: properties[
				"addressDiscovery"::const("[static]")
			], 
			then: oneOf[
				req["bigip"],
				{
					if: req["monitors"], 
					then: properties[
						"minimumMonitors"::
					],
					properties[
						""::not: type(str),
						"serverAddresses"::{
							uniqueItems,
							type(arr),
							items(;type(str))
						}
					],
					req["serverAddresses"]
				}
			],
			if: {
				properties[
					"addressDiscovery"::const("[fqdn]")
				],
				req["addressDiscovery"]
			}, 
			then: {
				if: req["monitors"], 
				then: properties[
					"minimumMonitors"::
				],
				properties[
					"hostname"::type(str),
					"downInterval"::{
						bet(0,null),
						type(int)
					},
					"autoPopulate"::type(bool),
					"queryInterval"::{
						bet(0,null),
						type(int)
					},
					"addressFamily"::{
						type(str),
						enum["IPv4", "IPv6"]
					}
				],
				req["hostname"]
			},
			if: {
				properties[
					"addressDiscovery"::const("[aws]")
				],
				req["addressDiscovery"]
			}, 
			then: ref: "#/definitions/Service_Discovery_AWS",
			if: {
				properties[
					"addressDiscovery"::const("[azure]")
				],
				req["addressDiscovery"]
			}, 
			then: ref: "#/definitions/Service_Discovery_Azure",
			if: {
				properties[
					"addressDiscovery"::const("[gce]")
				],
				req["addressDiscovery"]
			}, 
			then: ref: "#/definitions/Service_Discovery_GCE",
			if: {
				properties[
					"addressDiscovery"::const("[consul]")
				],
				req["addressDiscovery"]
			}, 
			then: ref: "#/definitions/Service_Discovery_Consul"
		],
		type(obj),
		properties[
			"rateLimit"::{
				bet(-1,2147483647),
				type(int)
			},
			"addressDiscovery"::{
				type(str),
				enum["static", "fqdn", "event", "aws", "gce", "azure", "consul"]
			},
			"dynamicRatio"::{
				bet(0,100),
				type(int)
			},
			"minimumMonitors"::{
				bet(0,63),
				type(int)
			},
			"priorityGroup"::{
				bet(0,65535),
				type(int)
			},
			"shareNodes"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"bigip"::type(str),
			"connectionLimit"::{
				bet(0,2147483647),
				type(int)
			},
			"enable"::type(bool),
			"adminState"::{
				type(str),
				enum["enable", "disable", "offline"]
			},
			"servicePort"::{
				bet(0,65535),
				type(int)
			},
			"ratio"::{
				bet(0,100),
				type(int)
			},
			"monitors"::{
				type(arr),
				items(;ref: "#/definitions/Basic_Monitor")
			}
		],
		req["servicePort"]
	},
	def "Pointer_Traffic_Log_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "GSLB_Server" = {
		allOf[
			if: properties[
				"serverType"::const("[generic-host]")
			], 
			then: properties[
				"cpuUsageLimitEnabled"::,
				"memoryLimitEnabled"::,
				"devices"::betitems(null,1),
				"cpuUsageLimit"::,
				"memoryLimit"::
			],
			if: properties[
				"serverType"::const("[bigip]")
			], 
			then: properties[
				"pathProbeEnabled"::,
				"snmpProbeEnabled"::,
				"serviceCheckProbeEnabled"::
			]
		],
		type(obj),
		properties[
			"cpuUsageLimitEnabled"::type(bool),
			"pathProbeEnabled"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"proberPreferred"::{
				type(str),
				enum["inherit", "inside-datacenter", "outside-datacenter", "pool"]
			},
			"ppsLimitEnabled"::type(bool),
			"enabled"::type(bool),
			"ppsLimit"::{
				bet(0,null),
				type(int)
			},
			"connectionsLimit"::{
				bet(0,null),
				type(int)
			},
			"cpuUsageLimit"::{
				bet(0,null),
				type(int)
			},
			"virtualServerDiscoveryMode"::{
				type(str),
				enum["disabled", "enabled", "enabled-no-delete"]
			},
			"proberPool"::ref: "#/definitions/Pointer_GSLB_Prober_Pool",
			"snmpProbeEnabled"::type(bool),
			"bpsLimit"::{
				bet(0,null),
				type(int)
			},
			"class"::{
				const("[GSLB_Server]"),
				type(str)
			},
			"bpsLimitEnabled"::type(bool),
			"serviceCheckProbeEnabled"::type(bool),
			"connectionsLimitEnabled"::type(bool),
			"memoryLimitEnabled"::type(bool),
			"proberFallback"::{
				type(str),
				enum["inherit", "any-available", "inside-datacenter", "none", "outside-datacenter", "pool"]
			},
			"dataCenter"::ref: "#/definitions/Pointer_GSLB_Data_Center",
			"devices"::{
				betitems(1,null),
				type(arr),
				items(;ref: "#/definitions/GSLB_Server_Device")
			},
			"virtualServers"::{
				type(arr),
				items(;ref: "#/definitions/GSLB_Virtual_Server")
			},
			"label"::ref: "#/definitions/Label",
			"exposeRouteDomainsEnabled"::type(bool),
			"serverType"::{
				type(str),
				enum["bigip", "generic-host"]
			},
			"memoryLimit"::{
				bet(0,null),
				type(int)
			},
			"monitors"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_GSLB_Monitor")
			},
			addp(
			|	cpuUsageLimitEnabled
			|	pathProbeEnabled
			|	remark
			|	proberPreferred
			|	ppsLimitEnabled
			|	enabled
			|	ppsLimit
			|	connectionsLimit
			|	cpuUsageLimit
			|	virtualServerDiscoveryMode
			|	proberPool
			|	snmpProbeEnabled
			|	bpsLimit
			|	class
			|	bpsLimitEnabled
			|	serviceCheckProbeEnabled
			|	connectionsLimitEnabled
			|	memoryLimitEnabled
			|	proberFallback
			|	dataCenter
			|	devices
			|	virtualServers
			|	label
			|	exposeRouteDomainsEnabled
			|	serverType
			|	memoryLimit
			|	monitors)::false
		],
		req["class",
			"dataCenter",
			"devices"]
	},
	def "Firewall_Rule_List" = {
		type(obj),
		properties[
			"remark"::ref: "#/definitions/Remark",
			"rules"::{
				type(arr),
				items(;ref: "#/definitions/Firewall_Rule")
			},
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Firewall_Rule_List]"),
				type(str)
			},
			addp(
			|	remark
			|	rules
			|	label
			|	class)::false
		],
		req["class"]
	},
	def "Monitor_HTTP" = {
		if: true, 
		then: ref: "#/definitions/Monitor_May_Adapt",
		properties[
			"receive"::type(str),
			"dscp"::{
				bet(0,63),
				type(int)
			},
			"passphrase"::{
				if: true, 
				then: ref: "#/definitions/Secret",
				type(obj),
				properties[
					"allowReuse"::type(bool)
				]
			},
			"reverse"::type(bool),
			"send"::type(str),
			"receiveDown"::type(str),
			"transparent"::type(bool),
			"username"::type(str)
		]
	},
	def "Pointer_GSLB_Monitor" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "JWE" = {
		type(obj),
		properties[
			"miniJWE"::type(bool),
			"ciphertext"::{
				length(2,null),
				type(str)
			},
			"protected"::{
				length(2,null),
				type(str)
			},
			"ignoreChanges"::type(bool)
		],
		req["protected"]
	},
	def "Bandwidth_Control_Policy" = {
		if: properties[
			"dynamicControlEnabled"::const([true])
		], 
		then: req["maxUserBandwidth"],
		type(obj),
		properties[
			"loggingEnabled"::type(bool),
			"logPublisher"::ref: "#/definitions/Pointer_Log_Publisher",
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"logPeriod"::{
				bet(0,1.8446744073709552E19),
				type(int)
			},
			"maxBandwidth"::{
				bet(0,1.8446744073709552E19),
				type(int)
			},
			"maxUserBandwidthUnit"::{
				type(str),
				enum["bps", "Kbps", "Mbps", "Gbps"]
			},
			"maxUserPPSUnit"::{
				type(str),
				enum["bpps", "Kpps", "Mpps", "Gpps"]
			},
			"dynamicControlEnabled"::type(bool),
			"maxUserPPS"::{
				bet(0,1.8446744073709552E19),
				type(int)
			},
			"markIP"::if: type(str), 
			then: const("[pass-through]"), 
			else: {
				bet(0,63),
				type(int)
			},
			"maxUserBandwidth"::{
				bet(0,1.8446744073709552E19),
				type(int)
			},
			"categories"::properties[
				addp()::ref: "#/definitions/Bandwidth_Control_Policy_Category"
			],
			"class"::{
				const("[Bandwidth_Control_Policy]"),
				type(str)
			},
			"maxBandwidthUnit"::{
				type(str),
				enum["bps", "Kbps", "Mbps", "Gbps"]
			},
			"markL2"::if: type(str), 
			then: const("[pass-through]"), 
			else: {
				bet(0,7),
				type(int)
			},
			addp(
			|	loggingEnabled
			|	logPublisher
			|	remark
			|	label
			|	logPeriod
			|	maxBandwidth
			|	maxUserBandwidthUnit
			|	maxUserPPSUnit
			|	dynamicControlEnabled
			|	maxUserPPS
			|	markIP
			|	maxUserBandwidth
			|	categories
			|	class
			|	maxBandwidthUnit
			|	markL2)::false
		],
		req["class",
			"maxBandwidth"]
	},
	def "Pointer_L4_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "DOS_Profile_Network" = {
		type(obj),
		properties[
			"vectors"::{
				type(arr),
				items(;ref: "#/definitions/DOS_Network_Vector")
			},
			"dynamicSignatures"::ref: "#/definitions/DOS_Profile_Network_Dynamic_Signatures",
			addp(
			|	vectors
			|	dynamicSignatures)::false
		]
	},
	def "Pointer_Enforcement_Policy" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_Service" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Data_Group_Records_Base" = {
		type(obj),
		properties[
			"records"::{
				type(arr),
				items(;{
					type(obj),
					properties[
						"value"::type(str)
					]
				})
			}
		]
	},
	def "Pointer_GSLB_Server_Device" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Policy_Action" = {
		allOf[
			if: properties[
				"type"::const("[http]")
			], 
			then: ref: "#/definitions/Policy_Action_HTTP",
			if: properties[
				"type"::const("[waf]")
			], 
			then: ref: "#/definitions/Policy_Action_WAF",
			if: properties[
				"type"::const("[forward]")
			], 
			then: ref: "#/definitions/Policy_Action_Forward",
			if: properties[
				"type"::const("[drop]")
			], 
			then: ref: "#/definitions/Policy_Action_Drop",
			if: properties[
				"type"::const("[httpRedirect]")
			], 
			then: ref: "#/definitions/Policy_Action_HTTP_Redirect",
			if: properties[
				"type"::const("[httpHeader]")
			], 
			then: ref: "#/definitions/Policy_Action_HTTP_Header",
			if: properties[
				"type"::const("[httpUri]")
			], 
			then: ref: "#/definitions/Policy_Action_HTTP_URI",
			if: properties[
				"type"::const("[httpCookie]")
			], 
			then: ref: "#/definitions/Policy_Action_HTTP_Cookie",
			if: properties[
				"type"::const("[serverSsl]")
			], 
			then: ref: "#/definitions/Policy_Action_Client_SSL",
			if: properties[
				"type"::const("[persist]")
			], 
			then: ref: "#/definitions/Policy_Action_Persist"
		],
		type(obj),
		properties[
			"type"::{
				type(str),
				enum["http", "httpCookie", "httpHeader", "httpRedirect", "httpUri", "waf", "forward", "drop", "clientSsl", "persist"]
			}
		],
		req["type"]
	},
	def "Enforcement_Subscriber_Management_Profile" = {
		type(obj),
		properties[
			"serverSideSessionsEnabled"::type(bool),
			"parentProfile"::ref: "#/definitions/Pointer_Enforcement_Subscriber_Management_Profile",
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Enforcement_Subscriber_Management_Profile]"),
				type(str)
			},
			"dhcpLeaseQuery"::ref: "#/definitions/Enforcement_Subscriber_Management_Profile_DHCP",
			addp(
			|	serverSideSessionsEnabled
			|	parentProfile
			|	remark
			|	label
			|	class
			|	dhcpLeaseQuery)::false
		],
		req["class"]
	},
	def "Enforcement_Rule_Quota" = properties[
		"ratingGroup"::ref: "#/definitions/Pointer_Enforcement_Rating_Group",
		"reportingLevel"::{
			type(str),
			enum["rating-group", "service-id"]
		},
		addp(
		|	ratingGroup
		|	reportingLevel)::false
	],
	def "Pointer_DNS_TSIG_Key" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "GSLB_Topology_Region" = {
		type(obj),
		properties[
			"members"::{
				type(arr),
				items(;ref: "#/definitions/GSLB_Topology_Condition")
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[GSLB_Topology_Region]"),
				type(str)
			}
		],
		req["class"]
	},
	def "Pointer_GSLB_Pool_Member_MX" = {
		type(obj),
		properties[
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_Enforcement_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "GSLB_Pool_MX" = ref: "#/definitions/GSLB_Pool",
	def "Pointer_Certificate_Validator_OCSP" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Security_Log_Profile" = {
		type(obj),
		properties[
			"ipIntelligence"::ref: "#/definitions/Security_Log_Profile_Ip_Intelligence",
			"nat"::ref: "#/definitions/Security_Log_Profile_Nat",
			"dosApplication"::ref: "#/definitions/Security_Log_Profile_Dos_Application",
			"botDefense"::ref: "#/definitions/Security_Log_Profile_Bot_Defense",
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"protocolSip"::ref: "#/definitions/Security_Log_Profile_Protocol_Sip",
			"classification"::ref: "#/definitions/Security_Log_Profile_Classification",
			"sshProxy"::ref: "#/definitions/Security_Log_Profile_Ssh_Proxy",
			"network"::ref: "#/definitions/Security_Log_Profile_Network",
			"protocolTransfer"::ref: "#/definitions/Security_Log_Profile_Protocol_Transfer",
			"application"::ref: "#/definitions/Security_Log_Profile_Application",
			"protocolDns"::ref: "#/definitions/Security_Log_Profile_Protocol_Dns",
			"dosNetwork"::ref: "#/definitions/Security_Log_Profile_Dos_Network",
			"class"::{
				const("[Security_Log_Profile]"),
				type(str)
			},
			"protocolDnsDos"::ref: "#/definitions/Security_Log_Profile_Protocol_Dns_Dos",
			"protocolSipDos"::ref: "#/definitions/Security_Log_Profile_Protocol_Sip_Dos"
		],
		req["class"]
	},
	def "GSLB_Pool_AAAA" = ref: "#/definitions/GSLB_Pool",
	def "Pointer_DOS_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Enforcement_Rule_Usage_Sd" = {
		properties[
			"applicationReportingEnabled"::type(bool),
			"monitoringKey"::type(str)
		],
		req["monitoringKey"]
	},
	def "Pointer_GSLB_Pool_A" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Security_Log_Profile_Dos_Network" = properties[
		"publisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		addp(
		|	publisher)::false
	],
	def "Pointer_HTTP_Acceleration_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_Data_Group_File" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Pointer_VLAN" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "L4_Profile" = {
		type(obj),
		properties[
			"maxSegmentSize"::{
				anyOf[
					bet(256,9162),
					const([0])
				],
				type(int)
			},
			"idleTimeout"::{
				anyOf[
					bet(1,86400),
					const([-1])
				],
				type(int)
			},
			"resetOnTimeout"::type(bool),
			"tcpCloseTimeout"::{
				bet(-1,86400),
				type(int)
			},
			"looseClose"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"clientTimeout"::{
				bet(-1,86400),
				type(int)
			},
			"label"::ref: "#/definitions/Label",
			"tcpHandshakeTimeout"::{
				bet(-1,86400),
				type(int)
			},
			"class"::{
				const("[L4_Profile]"),
				type(str)
			},
			"looseInitialization"::type(bool),
			addp(
			|	maxSegmentSize
			|	idleTimeout
			|	resetOnTimeout
			|	tcpCloseTimeout
			|	looseClose
			|	remark
			|	clientTimeout
			|	label
			|	tcpHandshakeTimeout
			|	class
			|	looseInitialization)::false
		],
		req["class"]
	},
	def "Rewrite_Profile_Set_Cookie_Rule" = {
		type(obj),
		properties[
			"server"::{
				type(obj),
				properties[
					"path"::{
						length(1,null),
						type(str)
					},
					"domain"::{
						length(1,null),
						type(str)
					},
					addp(
					|	path
					|	domain)::false
				],
				req["domain",
					"path"]
			},
			"client"::{
				type(obj),
				properties[
					"path"::{
						length(1,null),
						type(str)
					},
					"domain"::{
						length(1,null),
						type(str)
					},
					addp(
					|	path
					|	domain)::false
				],
				req["domain",
					"path"]
			},
			addp(
			|	server
			|	client)::false
		],
		req["client",
			"server"]
	},
	def "Multiplex_Profile" = {
		type(obj),
		properties[
			"maxConnectionAge"::{
				bet(0,null),
				type(int)
			},
			"idleTimeoutOverride"::{
				bet(0,null),
				type(int)
			},
			"sharePools"::type(bool),
			"connectionLimitEnforcement"::{
				type(str),
				enum["none", "idle", "strict"]
			},
			"remark"::ref: "#/definitions/Remark",
			"sourceMask"::type(str),
			"label"::ref: "#/definitions/Label",
			"maxConnectionReuse"::{
				bet(0,null),
				type(int)
			},
			"class"::{
				const("[Multiplex_Profile]"),
				type(str)
			},
			"maxConnections"::{
				bet(0,null),
				type(int)
			},
			addp(
			|	maxConnectionAge
			|	idleTimeoutOverride
			|	sharePools
			|	connectionLimitEnforcement
			|	remark
			|	sourceMask
			|	label
			|	maxConnectionReuse
			|	class
			|	maxConnections)::false
		],
		req["class"]
	},
	def "Pointer_HTTP2_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Persist_Cookie" = {
		if: properties[
			"cookieMethod"::const("[insert]")
		], 
		then: {
			if: {
				properties[
					"encrypt"::const([true])
				],
				req["encrypt"]
			}, 
			then: req["passphrase"],
			properties[
				"alwaysSet"::type(bool),
				"encrypt"::type(bool),
				"passphrase"::{
					if: true, 
					then: ref: "#/definitions/Secret",
					type(obj),
					properties[
						"allowReuse"::type(bool)
					]
				},
				"httpOnly"::type(bool),
				"secure"::type(bool),
				"ttl"::{
					bet(0,604800),
					type(int)
				}
			]
		}, 
		else: if: properties[
			"cookieMethod"::const("[hash]")
		], 
		then: properties[
			"hashCount"::{
				bet(0,4096),
				type(int)
			},
			"cookieName"::length(1,null),
			"startAt"::{
				bet(0,4096),
				type(int)
			}
		], 
		else: ,
		properties[
			"duration"::{
				bet(0,604800),
				type(int)
			},
			"cookieName"::{
				pattern("^[0-9A-Za-z.~#$%^&*_-]*$"),
				length(null,64),
				type(str)
			},
			"cookieMethod"::{
				type(str),
				enum["insert", "hash", "passive", "rewrite"]
			}
		]
	},
	def "Enforcement_Rule_Report_Destination_HSL" = properties[
		"highSpeedLogPublisher"::ref: "#/definitions/Pointer_Log_Publisher",
		"formatScript"::ref: "#/definitions/Pointer_Enforcement_Format_Script",
		addp(
		|	highSpeedLogPublisher
		|	formatScript)::false
	],
	def "Pointer_GSLB_Data_Center" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "GSLB_Data_Center" = {
		type(obj),
		properties[
			"proberFallback"::{
				type(str),
				enum["any-available", "inside-datacenter", "none", "outside-datacenter", "pool"]
			},
			"contact"::type(str),
			"proberPool"::ref: "#/definitions/Pointer_GSLB_Prober_Pool",
			"remark"::ref: "#/definitions/Remark",
			"location"::type(str),
			"label"::ref: "#/definitions/Label",
			"proberPreferred"::{
				type(str),
				enum["inside-datacenter", "outside-datacenter", "pool"]
			},
			"class"::{
				const("[GSLB_Data_Center]"),
				type(str)
			},
			"enabled"::type(bool),
			addp(
			|	proberFallback
			|	contact
			|	proberPool
			|	remark
			|	location
			|	label
			|	proberPreferred
			|	class
			|	enabled)::false
		],
		req["class"]
	},
	def "Certificate" = {
		if: req["pkcs12"], 
		then: , 
		else: {
			not: req["pkcs12"],
			req["certificate"]
		},
		type(obj),
		properties[
			"privateKey"::if: true, 
			then: ref: "#/definitions/F5string",
			"staplerOCSP"::ref: "#/definitions/Pointer_Certificate_Validator_OCSP",
			"chainCA"::if: true, 
			then: ref: "#/definitions/F5string",
			"pkcs12Options"::{
				type(obj),
				properties[
					"internalOnly"::{
						type(arr),
						items(;)
					},
					"ignoreChanges"::type(bool),
					"keyImportFormat"::{
						type(str),
						enum["pkcs8", "openssl-legacy"]
					}
				]
			},
			"certificate"::if: true, 
			then: ref: "#/definitions/F5string",
			"issuerCertificate"::{
				ref: "#/definitions/Pointer_SSL_Certificate",
				type(obj)
			},
			"remark"::ref: "#/definitions/Remark",
			"passphrase"::{
				if: true, 
				then: ref: "#/definitions/Secret",
				type(obj),
				properties[
					"allowReuse"::type(bool)
				]
			},
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Certificate]"),
				type(str)
			},
			"pkcs12"::if: true, 
			then: ref: "#/definitions/F5string",
			addp(
			|	privateKey
			|	staplerOCSP
			|	chainCA
			|	pkcs12Options
			|	certificate
			|	issuerCertificate
			|	remark
			|	passphrase
			|	label
			|	class
			|	pkcs12)::false
		],
		req["class"]
	},
	def "UDP_Profile" = {
		type(obj),
		properties[
			"bufferMaxPackets"::{
				bet(0,255),
				type(int)
			},
			"ttlIPv4"::{
				bet(1,255),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"ttlIPv6"::{
				bet(1,255),
				type(int)
			},
			"label"::ref: "#/definitions/Label",
			"ipDfMode"::{
				type(str),
				enum["clear", "pmtu", "preserve", "set"]
			},
			"ipTosToClient"::oneOf[
				{
					mof(4),
					bet(0,252),
					type(int)
				},
				{
					type(str),
					enum["pass-through", "mimic"]
				}
			],
			"useChecksum"::type(bool),
			"ttlMode"::{
				type(str),
				enum["decrement", "preserve", "proxy", "set"]
			},
			"idleTimeout"::{
				bet(-1,86400),
				type(int)
			},
			"linkQosToClient"::oneOf[
				{
					bet(0,7),
					type(int)
				},
				{
					const("[pass-through]"),
					type(str)
				}
			],
			"proxyMSS"::type(bool),
			"datagramLoadBalancing"::type(bool),
			"allowNoPayload"::type(bool),
			"class"::{
				const("[UDP_Profile]"),
				type(str)
			},
			"bufferMaxBytes"::{
				bet(65535,16777215),
				type(int)
			},
			addp(
			|	bufferMaxPackets
			|	ttlIPv4
			|	remark
			|	ttlIPv6
			|	label
			|	ipDfMode
			|	ipTosToClient
			|	useChecksum
			|	ttlMode
			|	idleTimeout
			|	linkQosToClient
			|	proxyMSS
			|	datagramLoadBalancing
			|	allowNoPayload
			|	class
			|	bufferMaxBytes)::false
		],
		req["class"]
	},
	def "DOS_Profile_Application_Stress_Based_Detection_Bad_Actor" = properties[
		"mitigationMode"::{
			type(str),
			enum["none", "conservative", "standard", "aggressive"]
		},
		"useApprovedSignaturesOnly"::type(bool),
		"detectionEnabled"::type(bool),
		"signatureDetectionEnabled"::type(bool),
		"acceleratedSignaturesEnabled"::type(bool),
		"tlsSignaturesEnabled"::type(bool),
		addp(
		|	mitigationMode
		|	useApprovedSignaturesOnly
		|	detectionEnabled
		|	signatureDetectionEnabled
		|	acceleratedSignaturesEnabled
		|	tlsSignaturesEnabled)::false
	],
	def "Pointer_GSLB_Pool_Member_AAAA" = {
		type(obj),
		properties[
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	use)::false
		],
		pro(1,1)
	},
	def "Monitor_SMTP" = properties[
		"domain"::type(str)
	],
	def "Policy_Action_Persist" = {
		allOf[
			properties[
				"event"::{
					type(str),
					enum["client-accepted", "proxy-request", "request"]
				}
			],
			oneOf[
				{
					properties[
						"disable"::{
							type(obj),
							properties[
								addp()::false
							]
						}
					],
					req["disable"]
				},
				{
					properties[
						"sourceAddress"::{
							type(obj),
							properties[
								"netmask"::type(str),
								"timeout"::{
									bet(0,65535),
									type(int)
								},
								addp(
								|	netmask
								|	timeout)::false
							],
							req["netmask",
								"timeout"]
						}
					],
					req["sourceAddress"]
				},
				{
					properties[
						"destinationAddress"::{
							type(obj),
							properties[
								"netmask"::type(str),
								"timeout"::{
									bet(0,65535),
									type(int)
								},
								addp(
								|	netmask
								|	timeout)::false
							],
							req["netmask",
								"timeout"]
						}
					],
					req["destinationAddress"]
				},
				{
					properties[
						"cookieInsert"::{
							type(obj),
							properties[
								"name"::type(str),
								"expiry"::type(str),
								addp(
								|	name
								|	expiry)::false
							],
							req["name",
								"expiry"]
						}
					],
					req["cookieInsert"]
				},
				{
					properties[
						"cookieRewrite"::{
							type(obj),
							properties[
								"name"::type(str),
								"expiry"::type(str),
								addp(
								|	name
								|	expiry)::false
							],
							req["name",
								"expiry"]
						}
					],
					req["cookieRewrite"]
				},
				{
					properties[
						"cookiePassive"::{
							type(obj),
							properties[
								"name"::type(str),
								addp(
								|	name)::false
							],
							req["name"]
						}
					],
					req["cookiePassive"]
				},
				{
					properties[
						"cookieHash"::{
							type(obj),
							properties[
								"offset"::{
									bet(0,65535),
									type(int)
								},
								"name"::type(str),
								"length"::{
									bet(0,65535),
									type(int)
								},
								"timeout"::{
									bet(0,65535),
									type(int)
								},
								addp(
								|	offset
								|	name
								|	length
								|	timeout)::false
							],
							req["name",
								"offset",
								"length",
								"timeout"]
						}
					],
					req["cookieHash"]
				},
				{
					properties[
						"universal"::{
							type(obj),
							properties[
								"key"::type(str),
								"timeout"::{
									bet(0,65535),
									type(int)
								},
								addp(
								|	key
								|	timeout)::false
							],
							req["key",
								"timeout"]
						}
					],
					req["universal"]
				},
				{
					properties[
						"hash"::{
							type(obj),
							properties[
								"key"::type(str),
								"timeout"::{
									bet(0,65535),
									type(int)
								},
								addp(
								|	key
								|	timeout)::false
							],
							req["key",
								"timeout"]
						}
					],
					req["hash"]
				},
				{
					properties[
						"carp"::{
							type(obj),
							properties[
								"key"::type(str),
								"timeout"::{
									bet(0,65535),
									type(int)
								},
								addp(
								|	key
								|	timeout)::false
							],
							req["key",
								"timeout"]
						}
					],
					req["carp"]
				}
			]
		],
		type(obj)
	},
	def "Enforcement_Service_Chain_Endpoint_Service_Endpoint" = {
		type(obj),
		properties[
			"serviceOption"::{
				type(str),
				enum["mandatory", "optional"]
			},
			"forwardingEndpoint"::ref: "#/definitions/Pointer_Enforcement_Forwarding_Endpoint",
			"internalService"::ref: "#/definitions/Pointer_Service",
			"name"::type(str),
			"internalServiceICAPType"::{
				type(str),
				enum["request", "response", "both", "none"]
			},
			"sourceVLAN"::ref: "#/definitions/Pointer_VLAN",
			"steeringPolicy"::ref: "#/definitions/Pointer_Enforcement_Policy",
			addp(
			|	serviceOption
			|	forwardingEndpoint
			|	internalService
			|	name
			|	internalServiceICAPType
			|	sourceVLAN
			|	steeringPolicy)::false
		],
		req["sourceVLAN"]
	},
	def "Enforcement_Listener" = {
		type(obj),
		properties[
			"subscriberManagementProfile"::ref: "#/definitions/Pointer_Enforcement_Subscriber_Management_Profile",
			"remark"::ref: "#/definitions/Remark",
			"enforcementProfile"::ref: "#/definitions/Pointer_Enforcement_Profile",
			"label"::ref: "#/definitions/Label",
			"services"::{
				betitems(1,null),
				type(arr),
				items(;ref: "#/definitions/Pointer_Service")
			},
			"class"::{
				const("[Enforcement_Listener]"),
				type(str)
			},
			addp(
			|	subscriberManagementProfile
			|	remark
			|	enforcementProfile
			|	label
			|	services
			|	class)::false
		],
		req["class",
			"enforcementProfile",
			"services"]
	},
	def "GSLB_Server_Device" = {
		type(obj),
		properties[
			"address"::type(str),
			"addressTranslation"::type(str),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label"
		],
		req["address"]
	},
	def "Pointer_Enforcement_Rating_Group" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Enforcement_Rule_Flow_Filter" = {
		properties[
			"destinationPort"::{
				bet(0,65535),
				type(int)
			},
			"sourcePort"::{
				bet(0,65535),
				type(int)
			},
			"protocol"::{
				type(str),
				enum["any", "tcp", "udp"]
			},
			"destinationAddress"::type(str),
			"sourceAddress"::type(str),
			"dscpMarking"::oneOf[
				{
					bet(0,63),
					type(int)
				},
				{
					const("[disabled]"),
					type(str)
				}
			],
			"name"::type(str),
			"invertMatch"::type(bool),
			"sourceVlan"::ref: "#/definitions/Pointer_VLAN",
			"ipAddressType"::{
				type(str),
				enum["any", "ipv4", "ipv6"]
			},
			addp(
			|	destinationPort
			|	sourcePort
			|	protocol
			|	destinationAddress
			|	sourceAddress
			|	dscpMarking
			|	name
			|	invertMatch
			|	sourceVlan
			|	ipAddressType)::false
		],
		req["name"]
	},
	def "Enum_Continent_Code_Alpha_2" = {
		type(str),
		enum["--", "AF", "AN", "AS", "EU", "NA", "OC", "SA"]
	},
	def "Pointer_Tunnel" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "SIP_Profile" = {
		type(obj),
		properties[
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[SIP_Profile]"),
				type(str)
			},
			addp(
			|	remark
			|	label
			|	class)::false
		],
		req["class"]
	},
	def "SSH_Proxy_Profile_Real_Server_Auth_Info" = {
		type(obj),
		properties[
			"publicKey"::type(str)
		]
	},
	def "FTP_Profile" = {
		type(obj),
		properties[
			"inheritParentProfileEnabled"::type(bool),
			"enforceTlsSessionReuseEnabled"::type(bool),
			"port"::{
				bet(0,65535),
				type(int)
			},
			"ftpsMode"::{
				type(str),
				enum["disallow", "allow", "require"]
			},
			"translateExtendedEnabled"::type(bool),
			"activeModeEnabled"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"securityEnabled"::type(bool),
			"class"::{
				const("[FTP_Profile]"),
				type(str)
			},
			addp(
			|	inheritParentProfileEnabled
			|	enforceTlsSessionReuseEnabled
			|	port
			|	ftpsMode
			|	translateExtendedEnabled
			|	activeModeEnabled
			|	remark
			|	label
			|	securityEnabled
			|	class)::false
		],
		req["class"]
	},
	def "NAT_Source_Translation" = {
		if: {
			properties[
				"allowEgressInterfaces"::true
			],
			req["allowEgressInterfaces"]
		}, 
		then: {
			not: {
				properties[
					"disallowEgressInterfaces"::true
				],
				req["disallowEgressInterfaces"]
			}
		},
		type(obj),
		properties[
			"patMode"::{
				type(str),
				enum["napt", "deterministic", "pba"]
			},
			"addresses"::{
				type(arr),
				items(;type(str))
			},
			"mapping"::ref: "#/definitions/NAT_Source_Translation_Mapping",
			"clientConnectionLimit"::{
				bet(0,2147483647),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"hairpinModeEnabled"::type(bool),
			"label"::ref: "#/definitions/Label",
			"ports"::{
				type(arr),
				items(;bet(0,65535))
			},
			"type"::{
				type(str),
				enum["dynamic-pat", "static-nat", "static-pat"]
			},
			"allowEgressInterfaces"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Tunnel")
			},
			"routeAdvertisement"::type(bool),
			"portBlockAllocation"::ref: "#/definitions/NAT_Source_Translation_PortBlockAllocation",
			"disallowEgressInterfaces"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Tunnel")
			},
			"inboundMode"::{
				type(str),
				enum["endpoint-independent-filtering", "explicit", "none"]
			},
			"class"::{
				const("[NAT_Source_Translation]"),
				type(str)
			},
			addp(
			|	patMode
			|	addresses
			|	mapping
			|	clientConnectionLimit
			|	remark
			|	hairpinModeEnabled
			|	label
			|	ports
			|	type
			|	allowEgressInterfaces
			|	routeAdvertisement
			|	portBlockAllocation
			|	disallowEgressInterfaces
			|	inboundMode
			|	class)::false
		],
		req["type"]
	},
	def "Controls" = {
		type(obj),
		properties[
			"trace"::type(bool),
			"fortune"::type(bool),
			"logLevel"::{
				type(str),
				enum["emergency", "alert", "critical", "error", "warning", "notice", "info", "debug"]
			},
			"class"::{
				const("[Controls]"),
				type(str)
			},
			addp(
			|	trace
			|	fortune
			|	logLevel
			|	class)::false
		]
	},
	def "Service_HTTPS" = {
		if: true, 
		then: ref: "#/definitions/Service_HTTP_Core",
		type(obj),
		properties[
			"redirect80"::type(bool),
			"class"::{
				const("[Service_HTTPS]"),
				type(str)
			},
			"virtualPort"::type(int)
		],
		req["class",
			"serverTLS"]
	},
	def "Enforcement_Rule_Usage_Reporting_Transaction" = properties[
		"hostname"::{
			bet(0,65535),
			type(int)
		},
		"userAgent"::{
			bet(0,65535),
			type(int)
		},
		"uri"::{
			bet(0,65535),
			type(int)
		},
		addp(
		|	hostname
		|	userAgent
		|	uri)::false
	],
	def "Monitor_ICMP" = {
		if: true, 
		then: ref: "#/definitions/Monitor_May_Adapt",
		properties[
			"transparent"::type(bool)
		]
	},
	def "Pointer_GSLB_Pool_Member_CNAME" = {
		type(obj),
		properties[
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	use)::false
		],
		pro(1,1)
	},
	def "GSLB_Pool_Member_MX" = {
		type(obj),
		properties[
			"domainName"::anyOf[
				ref: "#/definitions/Pointer_GSLB_Domain_A",
				ref: "#/definitions/Pointer_GSLB_Domain_AAAA"
			],
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"priority"::{
				bet(0,65535),
				type(int)
			},
			"ratio"::{
				bet(0,65535),
				type(int)
			},
			addp(
			|	domainName
			|	remark
			|	label
			|	priority
			|	ratio)::false
		],
		req["domainName",
			"priority",
			"ratio"]
	},
	def "Traffic_Log_Profile_Request_Settings" = {
		type(obj),
		properties[
			"requestPool"::ref: "#/definitions/Pointer_Pool",
			"proxyRespondOnLoggingErrorEnabled"::type(bool),
			"proxyResponse"::type(str),
			"requestErrorLoggingEnabled"::type(bool),
			"requestTemplate"::type(str),
			"requestErrorPool"::ref: "#/definitions/Pointer_Pool",
			"requestErrorProtocol"::{
				type(str),
				enum["mds-tcp", "mds-udp"]
			},
			"proxyCloseOnErrorEnabled"::type(bool),
			"requestErrorTemplate"::type(str),
			"requestProtocol"::{
				type(str),
				enum["mds-tcp", "mds-udp"]
			},
			"requestEnabled"::type(bool),
			addp(
			|	requestPool
			|	proxyRespondOnLoggingErrorEnabled
			|	proxyResponse
			|	requestErrorLoggingEnabled
			|	requestTemplate
			|	requestErrorPool
			|	requestErrorProtocol
			|	proxyCloseOnErrorEnabled
			|	requestErrorTemplate
			|	requestProtocol
			|	requestEnabled)::false
		]
	},
	def "DOS_Auto_Blacklist_Settings" = {
		type(obj),
		properties[
			"categoryDuration"::{
				bet(60,4294967295),
				type(int)
			},
			"attackDetectionTime"::{
				bet(1,4294967295),
				type(int)
			},
			"category"::ref: "#/definitions/Pointer_Blacklist_Category",
			"enabled"::type(bool),
			"externalAdvertisementEnabled"::type(bool),
			addp(
			|	categoryDuration
			|	attackDetectionTime
			|	category
			|	enabled
			|	externalAdvertisementEnabled)::false
		]
	},
	def "GSLB_Pool_Member_A" = {
		type(obj),
		properties[
			"server"::ref: "#/definitions/Pointer_GSLB_Server",
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"virtualServer"::type(str),
			"ratio"::{
				bet(0,65535),
				type(int)
			},
			addp(
			|	server
			|	remark
			|	label
			|	virtualServer
			|	ratio)::false
		],
		req["server",
			"virtualServer"]
	},
	def "Service_HTTP" = {
		if: true, 
		then: ref: "#/definitions/Service_HTTP_Core",
		type(obj),
		properties[
			"class"::{
				const("[Service_HTTP]"),
				type(str)
			},
			"virtualPort"::type(int)
		],
		req["class"]
	},
	def "Firewall_Rule_Source" = {
		type(obj),
		properties[
			"addressLists"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Firewall_Address_List")
			},
			"portLists"::{
				type(arr),
				items(;{
					type(obj),
					properties[
						"bigip"::type(str),
						"use"::{
							length(1,null),
							type(str)
						},
						addp(
						|	bigip
						|	use)::false
					],
					pro(1,1)
				})
			},
			addp(
			|	addressLists
			|	portLists)::false
		]
	},
	def "DOS_Profile_Application_Detection_URL" = {
		type(obj),
		properties[
			"minimumTps"::{
				bet(0,4294967295),
				type(int)
			},
			"maximumTps"::{
				bet(0,4294967295),
				type(int)
			},
			"minimumAutoTps"::{
				bet(0,4294967295),
				type(int)
			},
			"clientSideDefenseEnabled"::type(bool),
			"tpsIncreaseRate"::{
				bet(0,4294967295),
				type(int)
			},
			"captchaChallengeEnabled"::type(bool),
			"rateLimitingEnabled"::type(bool),
			"maximumAutoTps"::{
				bet(0,4294967295),
				type(int)
			},
			"heavyURLProtectionEnabled"::type(bool),
			addp(
			|	minimumTps
			|	maximumTps
			|	minimumAutoTps
			|	clientSideDefenseEnabled
			|	tpsIncreaseRate
			|	captchaChallengeEnabled
			|	rateLimitingEnabled
			|	maximumAutoTps
			|	heavyURLProtectionEnabled)::false
		]
	},
	def "Clone_Pools" = {
		anyOf[
			req["ingress"],
			req["egress"]
		],
		type(obj),
		properties[
			"ingress"::ref: "#/definitions/Pointer_Pool",
			"egress"::ref: "#/definitions/Pointer_Pool",
			addp(
			|	ingress
			|	egress)::false
		]
	},
	def "GSLB_Topology_Records" = {
		type(obj),
		properties[
			"records"::{
				betitems(1,null),
				type(arr),
				items(;ref: "#/definitions/GSLB_Topology_Record")
			},
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[GSLB_Topology_Records]"),
				type(str)
			},
			"longestMatchEnabled"::type(bool)
		],
		req["class",
			"records"]
	},
	def "Pointer_DNS_Zone" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Template_generic" = properties[
		"template"::type(str),
		"serviceMain"::ref: "#/definitions/Service_Generic"
	],
	def "Service_HTTP_Core" = {
		if: true, 
		then: ref: "#/definitions/Service_TCP_Core",
		properties[
			"persistenceMethods"::{
				type(arr),
				items(;ref: "#/definitions/Basic_Persist")
			},
			"profileHTTP"::if: not: type(obj), 
			then: {
				type(str),
				enum["basic"]
			}, 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					},
					addp(
					|	bigip
					|	use)::false
				],
				pro(1,1)
			},
			"profileHTTP2"::if: not: type(obj), 
			then: {
				type(str),
				enum["basic"]
			}, 
			else: ref: "#/definitions/Pointer_HTTP2_Profile",
			"profileAnalytics"::ref: "#/definitions/Pointer_Analytics_Profile",
			"policyWAF"::ref: "#/definitions/Pointer_WAF_Policy",
			"profileMultiplex"::if: not: type(obj), 
			then: {
				type(str),
				enum["basic"]
			}, 
			else: ref: "#/definitions/Pointer_Multiplex_Profile",
			"profileHTTPAcceleration"::if: not: type(obj), 
			then: {
				type(str),
				enum["basic"]
			}, 
			else: ref: "#/definitions/Pointer_HTTP_Acceleration_Profile",
			"profileHTTPCompression"::if: not: type(obj), 
			then: {
				type(str),
				enum["basic", "wan"]
			}, 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					},
					addp(
					|	bigip
					|	use)::false
				],
				pro(1,1)
			},
			"policyIAM"::{
				type(obj),
				properties[
					"bigip"::type(str),
					addp(
					|	bigip)::false
				],
				req["bigip"]
			}
		],
		req["class"]
	},
	def "Basic_Monitor" = if: type(str), 
	then: enum["http", "https", "icmp", "tcp-half-open", "tcp"], 
	else: {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		]
	},
	def "iRule" = {
		type(obj),
		properties[
			"expand"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"iRule"::if: true, 
			then: ref: "#/definitions/F5string",
			"class"::{
				const("[iRule]"),
				type(str)
			},
			addp(
			|	expand
			|	remark
			|	label
			|	iRule
			|	class)::false
		],
		req["class",
			"iRule"]
	},
	def "Enforcement_Rule_Usage_Hsl" = {
		properties[
			"sessionReportingFields"::{
				type(arr),
				items(;{
					type(str),
					enum["3gpp-parameters", "application-id", "called-station-id", "calling-station-id", "concurrent-flows", "downlink-volume", "duration-seconds", "last-record-sent", "new-flows", "observation-time-seconds", "record-reason", "record-type", "report-id", "report-version", "subscriber-id", "subscriber-id-type", "successful-transactions", "terminated-flows", "timestamp-msec", "total-transactions", "uplink-volume"]
				})
			},
			"transactionReportingFields"::{
				type(arr),
				items(;{
					type(str),
					enum["application-id", "destination-ip", "destination-transport-port", "downlink-volume", "http-hostname", "http-hostname-truncated", "http-response-code", "http-url", "http-url-truncated", "http-user-agent", "http-user-agent-truncated", "protocol-identifier", "record-type", "report-id", "report-version", "route-domain", "skipped-transactions", "source-ip", "source-transport-port", "subscriber-id", "subscriber-id-type", "transaction-classification-result", "transaction-end-milli-seconds", "transaction-end-seconds", "transaction-number", "transaction-start-milli-seconds", "transaction-start-seconds", "uplink-volume", "url-category-id", "vlan-id"]
				})
			},
			"publisher"::ref: "#/definitions/Pointer_Log_Publisher",
			"formatScript"::ref: "#/definitions/Pointer_Enforcement_Format_Script",
			"flowReportingFields"::{
				type(arr),
				items(;{
					type(str),
					enum["application-id", "destination-ip", "destination-transport-port", "downlink-volume", "flow-end-milli-seconds", "flow-end-seconds", "flow-start-milli-seconds", "flow-start-seconds", "observation-time-seconds", "protocol-identifier", "record-type", "report-id", "report-version", "route-domain", "source-ip", "source-transport-port", "subscriber-id", "subscriber-id-type", "timestamp-msec", "total-transactions", "uplink-volume", "url-category-id", "vlan-id"]
				})
			}
		],
		req["publisher"]
	},
	def "ADC_Array" = {
		betitems(1,null),
		type(arr),
		items(;ref: "#/definitions/ADC")
	},
	def "Pointer_TCP_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Security_Log_Profile_Classification" = properties[
		"publisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		"logAllMatches"::type(bool),
		addp(
		|	publisher
		|	logAllMatches)::false
	],
	def "Enforcement_Service_Chain_Endpoint" = {
		type(obj),
		properties[
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Enforcement_Service_Chain_Endpoint]"),
				type(str)
			},
			"serviceEndpoints"::{
				type(arr),
				items(;ref: "#/definitions/Enforcement_Service_Chain_Endpoint_Service_Endpoint")
			},
			addp(
			|	remark
			|	label
			|	class
			|	serviceEndpoints)::false
		],
		req["class"]
	},
	def "SSH_Proxy_Profile_Rule_Collection" = {
		anyOf[
			req["sshProfileIdUsers"],
			req["sshProfileIdGroups"]
		],
		type(obj),
		properties[
			"sshProfileIdUsers"::{
				betitems(1,null),
				type(arr),
				items(;type(str))
			},
			"sshProfileIdGroups"::{
				type(arr),
				items(;type(str))
			},
			"name"::type(str),
			"remark"::ref: "#/definitions/Remark",
			"sshProfileRuleActions"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action_Collection",
			addp(
			|	sshProfileIdUsers
			|	sshProfileIdGroups
			|	name
			|	remark
			|	sshProfileRuleActions)::false
		],
		req["name"]
	},
	def "Pointer_GSLB_Topology_Region" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_Enforcement_iRule" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "GSLB_Prober_Pool" = {
		type(obj),
		properties[
			"members"::{
				type(arr),
				items(;ref: "#/definitions/GSLB_Prober_Pool_Member")
			},
			"label"::ref: "#/definitions/Label",
			"lbMode"::{
				type(str),
				enum["global-availability", "round-robin"]
			},
			"class"::{
				const("[GSLB_Prober_Pool]"),
				type(str)
			},
			"enabled"::type(bool)
		]
	},
	def "Pointer_GSLB_Prober_Pool" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "GSLB_Domain_AAAA" = ref: "#/definitions/GSLB_Domain",
	def "DOS_Profile_Application_Captcha" = {
		type(obj),
		properties[
			"failure"::{
				length(null,65520),
				type(str)
			},
			"first"::{
				length(null,65520),
				type(str)
			},
			addp(
			|	failure
			|	first)::false
		]
	},
	def "Policy_Action_Drop" = {
		type(obj),
		properties[
			"event"::{
				type(str),
				enum["ssl-client-hello", "request"]
			}
		]
	},
	def "DNS_Profile" = {
		properties[
			"rapidResponseLastAction"::{
				type(str),
				enum["allow", "drop", "noerror", "nxdomain", "refuse", "truncate"]
			},
			"dnssecEnabled"::type(bool),
			"dns64AdditionalSectionRewrite"::{
				type(str),
				enum["disabled", "v6-only", "v4-only", "any"]
			},
			"zoneTransferEnabled"::type(bool),
			"dns64Prefix"::type(str),
			"globalServerLoadBalancingEnabled"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"loggingProfile"::ref: "#/definitions/Pointer_DNS_Logging_Profile",
			"hardwareQueryValidationEnabled"::type(bool),
			"securityProfile"::ref: "#/definitions/Pointer_DNS_Security_Profile",
			"class"::{
				const("[DNS_Profile]"),
				type(str)
			},
			"localBindServerEnabled"::type(bool),
			"cache"::ref: "#/definitions/Pointer_DNS_Cache",
			"loggingEnabled"::type(bool),
			"hardwareResponseCacheEnabled"::type(bool),
			"unhandledQueryAction"::{
				type(str),
				enum["allow", "drop", "hint", "noerror", "reject"]
			},
			"label"::ref: "#/definitions/Label",
			"rapidResponseEnabled"::type(bool),
			"recursionDesiredEnabled"::type(bool),
			"cacheEnabled"::type(bool),
			"parentProfile"::ref: "#/definitions/Pointer_DNS_Profile",
			"dns64Mode"::{
				type(str),
				enum["disabled", "secondary", "immediate", "v4-only"]
			},
			"dnsExpressEnabled"::type(bool),
			"securityEnabled"::type(bool),
			"statisticsSampleRate"::{
				bet(0,4294967295),
				type(int)
			},
			addp(
			|	rapidResponseLastAction
			|	dnssecEnabled
			|	dns64AdditionalSectionRewrite
			|	zoneTransferEnabled
			|	dns64Prefix
			|	globalServerLoadBalancingEnabled
			|	remark
			|	loggingProfile
			|	hardwareQueryValidationEnabled
			|	securityProfile
			|	class
			|	localBindServerEnabled
			|	cache
			|	loggingEnabled
			|	hardwareResponseCacheEnabled
			|	unhandledQueryAction
			|	label
			|	rapidResponseEnabled
			|	recursionDesiredEnabled
			|	cacheEnabled
			|	parentProfile
			|	dns64Mode
			|	dnsExpressEnabled
			|	securityEnabled
			|	statisticsSampleRate)::false
		],
		req["class"]
	},
	def "DNS_Nameserver" = {
		properties[
			"routeDomain"::ref: "#/definitions/Pointer_Route_Domain",
			"address"::type(str),
			"port"::{
				bet(0,65535),
				type(int)
			},
			"tsigKey"::ref: "#/definitions/Pointer_DNS_TSIG_Key",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[DNS_Nameserver]"),
				type(str)
			},
			addp(
			|	routeDomain
			|	address
			|	port
			|	tsigKey
			|	label
			|	class)::false
		],
		req["class"]
	},
	def "Persist_Addr" = properties[
		"duration"::{
			bet(0,604800),
			type(int)
		},
		"addressMask"::type(str),
		"hashAlgorithm"::{
			type(str),
			enum["carp", "default"]
		}
	],
	def "Firewall_Policy" = {
		type(obj),
		properties[
			"remark"::ref: "#/definitions/Remark",
			"rules"::{
				type(arr),
				items(;if: oneOf[
					req["use"],
					req["bigip"]
				], 
				then: ref: "#/definitions/Pointer_Firewall_Rule_List", 
				else: ref: "#/definitions/Firewall_Rule")
			},
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Firewall_Policy]"),
				type(str)
			},
			addp(
			|	remark
			|	rules
			|	label
			|	class)::false
		],
		req["class",
			"rules"]
	},
	def "Pointer_GSLB_Pool_MX" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Enforcement_Forwarding_Endpoint_Hash_Settings" = {
		type(obj),
		properties[
			"offset"::{
				bet(0,4294967295),
				type(int)
			},
			"length"::{
				bet(0,4294967295),
				type(int)
			},
			"tclScript"::type(str),
			addp(
			|	offset
			|	length
			|	tclScript)::false
		]
	},
	def "Traffic_Log_Profile" = {
		type(obj),
		properties[
			"responseSettings"::ref: "#/definitions/Traffic_Log_Profile_Response_Settings",
			"parentProfile"::ref: "#/definitions/Pointer_Traffic_Log_Profile",
			"requestSettings"::ref: "#/definitions/Traffic_Log_Profile_Request_Settings",
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Traffic_Log_Profile]"),
				type(str)
			},
			addp(
			|	responseSettings
			|	parentProfile
			|	requestSettings
			|	remark
			|	label
			|	class)::false
		],
		req["class"]
	},
	def "HTTP_Profile" = {
		if: properties[
			"proxyType"::const("[reverse]")
		], 
		then: ref: "#/definitions/HTTP_Profile_Reverse", 
		else: if: properties[
			"proxyType"::const("[transparent]")
		], 
		then: ref: "#/definitions/HTTP_Profile_Transparent", 
		else: if: properties[
			"proxyType"::const("[explicit]")
		], 
		then: ref: "#/definitions/HTTP_Profile_Explicit",
		type(obj),
		properties[
			"trustXFF"::type(bool),
			"fallbackRedirect"::{
				length(1,null),
				type(str)
			},
			"unknownMethodAction"::{
				type(str),
				enum["allow", "reject", "pass-through"]
			},
			"pipelineAction"::{
				type(str),
				enum["allow", "reject", "pass-through"]
			},
			"remark"::ref: "#/definitions/Remark",
			"allowedResponseHeaders"::{
				uniqueItems,
				type(arr),
				items(;{
					length(1,128),
					pattern("^[^\x00-\x20\x22:\x5c\x7f-\xff]+$"),
					type(str)
				})
			},
			"webSocketMasking"::{
				type(str),
				enum["preserve", "remask", "selective", "unmask"]
			},
			"requestChunking"::{
				type(str),
				enum["selective", "preserve", "rechunk"]
			},
			"hstsPreload"::type(bool),
			"viaHost"::{
				length(1,null),
				type(str)
			},
			"responseChunking"::{
				type(str),
				enum["selective", "preserve", "unchunk", "rechunk"]
			},
			"cookiePassphrase"::{
				if: true, 
				then: ref: "#/definitions/Secret",
				type(obj),
				properties[
					"allowReuse"::type(bool)
				]
			},
			"webSocketsEnabled"::type(bool),
			"fallbackStatusCodes"::{
				uniqueItems,
				type(arr),
				items(;{
					bet(100,999),
					type(int)
				})
			},
			"class"::{
				const("[HTTP_Profile]"),
				type(str)
			},
			"hstsIncludeSubdomains"::type(bool),
			"viaRequest"::{
				type(str),
				enum["append", "preserve", "remove"]
			},
			"viaResponse"::{
				type(str),
				enum["append", "preserve", "remove"]
			},
			"proxyType"::{
				type(str),
				enum["reverse", "transparent", "explicit"]
			},
			"rewriteRedirects"::{
				type(str),
				enum["none", "all", "matching", "addresses"]
			},
			"label"::ref: "#/definitions/Label",
			"encryptCookies"::{
				uniqueItems,
				type(arr),
				items(;{
					pattern("^[^\x00-\x20\x22=\x5c\x7f-\xff]+$"),
					type(str)
				})
			},
			"whiteOutHeader"::{
				length(1,128),
				pattern("^[^\x00-\x20\x22:\x5c\x7f-\xff]+$"),
				type(str)
			},
			"serverHeaderValue"::type(str),
			"knownMethods"::{
				uniqueItems,
				type(arr),
				items(;{
					length(1,32),
					pattern("^[A-Z0-9]+$"),
					type(str)
				})
			},
			"insertHeader"::{
				type(obj),
				properties[
					"name"::{
						length(1,128),
						pattern("^[^\x00-\x20\x22:\x5c\x7f-\xff]+$"),
						type(str)
					},
					"value"::{
						pattern("^[^\x00-\x1f\x7f-\xff]*$"),
						type(str)
					},
					addp(
					|	name
					|	value)::false
				]
			},
			"multiplexTransformations"::type(bool),
			"otherXFF"::{
				uniqueItems,
				type(arr),
				items(;{
					length(1,128),
					pattern("^[^\x00-\x20\x22:\x5c\x7f-\xff]+$"),
					type(str)
				})
			},
			"maxRequests"::{
				bet(0,2147483647),
				type(int)
			},
			"hstsPeriod"::{
				bet(0,31557600),
				type(int)
			},
			"xForwardedFor"::type(bool),
			"hstsInsert"::type(bool)
		],
		req["class"]
	},
	def "Policy_Action_Forward_Select" = {
		oneOf[
			{
				properties[
					"pool"::ref: "#/definitions/Pointer_Pool"
				],
				req["pool"]
			},
			{
				properties[
					"service"::ref: "#/definitions/Pointer_Service"
				],
				req["service"]
			}
		],
		type(obj)
	},
	def "Persist_TLS_Session" = properties[
		"duration"::{
			bet(0,604800),
			type(int)
		}
	],
	def "Service_Discovery_Polling_Core_Tagged" = {
		ref: "#/definitions/Service_Discovery_Polling_Core",
		properties[
			"tagValue"::{
				length(1,null),
				type(str)
			},
			"tagKey"::{
				length(1,null),
				type(str)
			}
		],
		req["tagKey",
			"tagValue"]
	},
	def "GSLB_Domain" = {
		if: {
			properties[
				"pools"::true
			],
			req["pools"]
		}, 
		then: {
			not: {
				properties[
					"poolsCname"::true
				],
				req["poolsCname"]
			}
		},
		type(obj),
		properties[
			"resourceRecordType"::{
				type(str),
				enum["A", "AAAA", "CNAME", "MX"]
			},
			"aliases"::{
				type(arr),
				items(;{
					length(3,null),
					type(str)
				})
			},
			"poolsCname"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_GSLB_Pool")
			},
			"lastResortPool"::ref: "#/definitions/Pointer_GSLB_Pool",
			"domainName"::{
				length(3,null),
				type(str)
			},
			"lastResortPoolType"::{
				type(str),
				enum["A", "AAAA", "CNAME", "MX"]
			},
			"pools"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_GSLB_Pool")
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[GSLB_Domain]"),
				type(str)
			},
			"enabled"::type(bool),
			"poolLbMode"::{
				type(str),
				enum["global-availability", "ratio", "round-robin", "topology"]
			}
		],
		req["resourceRecordType",
			"domainName"]
	},
	def "Policy_Action_HTTP_Redirect" = {
		type(obj),
		properties[
			"location"::type(str),
			"event"::{
				type(str),
				enum["proxy-request", "request", "response"]
			}
		],
		req["location"]
	},
	def "GSLB_Topology_Condition" = {
		allOf[
			if: properties[
				"matchType"::const("[continent]")
			], 
			then: properties[
				"matchValue"::ref: "#/definitions/Enum_Continent_Code_Alpha_2"
			],
			if: properties[
				"matchType"::const("[country]")
			], 
			then: properties[
				"matchValue"::ref: "#/definitions/Enum_Country_Code_Alpha_2"
			],
			if: properties[
				"matchType"::const("[datacenter]")
			], 
			then: properties[
				"matchValue"::ref: "#/definitions/Pointer_GSLB_Data_Center"
			],
			if: properties[
				"matchType"::const("[geoip-isp]")
			], 
			then: properties[
				"matchValue"::type(str)
			],
			if: properties[
				"matchType"::const("[isp]")
			], 
			then: properties[
				"matchValue"::ref: "#/definitions/Enum_ISP"
			],
			if: properties[
				"matchType"::const("[pool]")
			], 
			then: properties[
				"matchValue"::anyOf[
					ref: "#/definitions/Pointer_GSLB_Pool_A",
					ref: "#/definitions/Pointer_GSLB_Pool_AAAA",
					ref: "#/definitions/Pointer_GSLB_Pool_CNAME",
					ref: "#/definitions/Pointer_GSLB_Pool_MX"
				]
			],
			if: properties[
				"matchType"::const("[region]")
			], 
			then: properties[
				"matchValue"::ref: "#/definitions/Pointer_GSLB_Topology_Region"
			],
			if: properties[
				"matchType"::const("[state]")
			], 
			then: properties[
				"matchValue"::{
					length(4,null),
					type(str)
				}
			],
			if: properties[
				"matchType"::const("[subnet]")
			], 
			then: properties[
				"matchValue"::type(str)
			]
		],
		type(obj),
		properties[
			"matchType"::{
				type(str),
				enum["continent", "country", "datacenter", "geoip-isp", "isp", "pool", "region", "state", "subnet"]
			},
			"matchValue"::,
			"matchOperator"::{
				type(str),
				enum["equals", "not-equals"]
			}
		],
		req["matchType",
			"matchValue"]
	},
	def "Pointer_Route_Domain" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "SSH_Proxy_Profile_Default_Action" = {
		type(obj),
		properties[
			"log"::type(bool),
			"control"::{
				type(str),
				enum["allow", "disallow", "terminate", "unspecified"]
			},
			addp(
			|	log
			|	control)::false
		]
	},
	def "Pointer_Classification_Application" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Enforcement_Rule_Usage_Gx" = properties[
		"applicationReportingEnabled"::type(bool),
		"monitoringKey"::type(str)
	],
	def "Pointer_Enforcement_Radius_AAA_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_FTP_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Pointer_Blacklist_Category" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Firewall_Address_List" = {
		anyOf[
			req["addresses"],
			req["fqdns"],
			req["geo"],
			req["addressLists"]
		],
		type(obj),
		properties[
			"geo"::{
				betitems(1,null),
				type(arr),
				items(;type(str))
			},
			"addressLists"::{
				betitems(1,null),
				type(arr),
				items(;ref: "#/definitions/Pointer_Firewall_Address_List")
			},
			"addresses"::{
				betitems(1,null),
				type(arr),
				items(;oneOf[
					type(str),
					{
						allOf[
							if: properties[
								"addressDiscovery"::const("[aws]")
							], 
							then: ref: "#/definitions/Service_Discovery_AWS",
							if: properties[
								"addressDiscovery"::const("[azure]")
							], 
							then: ref: "#/definitions/Service_Discovery_Azure",
							if: properties[
								"addressDiscovery"::const("[gce]")
							], 
							then: ref: "#/definitions/Service_Discovery_GCE",
							if: properties[
								"addressDiscovery"::const("[consul]")
							], 
							then: ref: "#/definitions/Service_Discovery_Consul"
						],
						type(obj),
						properties[
							"addressDiscovery"::{
								type(str),
								enum["event", "aws", "gce", "azure", "consul"]
							},
							"updateInterval"::{
								bet(1,3600),
								type(int)
							}
						],
						req["addressDiscovery"]
					}
				])
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"fqdns"::{
				betitems(1,null),
				type(arr),
				items(;type(str))
			},
			"class"::{
				const("[Firewall_Address_List]"),
				type(str)
			},
			addp(
			|	geo
			|	addressLists
			|	addresses
			|	remark
			|	label
			|	fqdns
			|	class)::false
		],
		req["class"]
	},
	def "Monitor_DNS" = {
		allOf[
			if: true, 
			then: ref: "#/definitions/Monitor_May_Adapt",
			if: {
				properties[
					"transparent"::const([true])
				],
				req["transparent"]
			}, 
			then: allOf[
				req["targetAddress",
					"targetPort"],
				properties[
					"targetAddress"::not: const("[]")
				]
			],
			if: {
				properties[
					"reverse"::const([true])
				],
				req["reverse"]
			}, 
			then: allOf[
				req["receive"],
				properties[
					"receive"::not: const("[]")
				]
			],
			if: properties[
				"answerContains"::const("[query-type]"),
				"acceptRCODE"::const("[no-error]")
			], 
			then: properties[
				"receive"::
			]
		],
		properties[
			"answerContains"::{
				type(str),
				enum["any-type", "anything", "query-type"]
			},
			"receive"::type(str),
			"queryName"::{
				length(1,null),
				type(str)
			},
			"acceptRCODE"::{
				type(str),
				enum["anything", "no-error"]
			},
			"reverse"::type(bool),
			"transparent"::type(bool),
			"queryType"::{
				type(str),
				enum["a", "aaaa"]
			}
		],
		req["queryName"]
	},
	def "DOS_Profile_Application_Detection_Device" = {
		type(obj),
		properties[
			"minimumTps"::{
				bet(0,4294967295),
				type(int)
			},
			"maximumTps"::{
				bet(0,4294967295),
				type(int)
			},
			"minimumAutoTps"::{
				bet(0,4294967295),
				type(int)
			},
			"clientSideDefenseEnabled"::type(bool),
			"tpsIncreaseRate"::{
				bet(0,4294967295),
				type(int)
			},
			"captchaChallengeEnabled"::type(bool),
			"rateLimitingEnabled"::type(bool),
			"maximumAutoTps"::{
				bet(0,4294967295),
				type(int)
			},
			"rateLimitingMode"::{
				type(str),
				enum["rate-limit", "block-all"]
			},
			addp(
			|	minimumTps
			|	maximumTps
			|	minimumAutoTps
			|	clientSideDefenseEnabled
			|	tpsIncreaseRate
			|	captchaChallengeEnabled
			|	rateLimitingEnabled
			|	maximumAutoTps
			|	rateLimitingMode)::false
		]
	},
	def "Pointer_Multiplex_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_GSLB_Prober_Pool_Member" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Template_tcp" = {
		properties[
			"serviceMain"::ref: "#/definitions/Service_TCP"
		],
		req["serviceMain"]
	},
	def "Security_Log_Profile_Ip_Intelligence" = properties[
		"logTranslationFields"::type(bool),
		"publisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		"rateLimitAggregate"::type(int),
		addp(
		|	logTranslationFields
		|	publisher
		|	rateLimitAggregate)::false
	],
	def "Enforcement_Rule_Modify_HTTP_Header" = {
		if: properties[
			"operation"::const("[insert]")
		], 
		then: req["valueContent"],
		properties[
			"headerName"::type(str),
			"valueType"::{
				type(str),
				enum["string", "tcl-snippet"]
			},
			"valueContent"::type(str),
			"operation"::{
				type(str),
				enum["insert", "remove"]
			},
			addp(
			|	headerName
			|	valueType
			|	valueContent
			|	operation)::false
		],
		req["headerName",
			"operation"]
	},
	def "Service_Generic" = {
		ref: "#/definitions/Service_L4_Core",
		type(obj),
		properties[
			"profileIPOther"::ref: "#/definitions/Pointer_IP_Other_Profile",
			"layer4"::type(str),
			"class"::{
				const("[Service_Generic]"),
				type(str)
			}
		],
		req["class"]
	},
	def "Pointer_Bot_Signature_Category" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "SSH_Proxy_Profile_Rule_Action_Collection" = {
		type(obj),
		properties[
			"rexecAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"scpDownAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"shellAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"x11ForwardAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"agentAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"otherAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"localForwardAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"remoteForwardAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"scpUpAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"sftpUpAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"name"::type(str),
			"sftpDownAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			"subSystemAction"::ref: "#/definitions/SSH_Proxy_Profile_Rule_Action",
			addp(
			|	rexecAction
			|	scpDownAction
			|	shellAction
			|	x11ForwardAction
			|	agentAction
			|	otherAction
			|	localForwardAction
			|	remoteForwardAction
			|	scpUpAction
			|	sftpUpAction
			|	name
			|	sftpDownAction
			|	subSystemAction)::false
		]
	},
	def "HTTP2_Profile" = {
		type(obj),
		properties[
			"activationMode"::{
				type(str),
				enum["alpn", "always"]
			},
			"headerTableSize"::{
				bet(0,65535),
				type(int)
			},
			"includeContentLength"::type(bool),
			"insertHeaderName"::type(str),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"writeSize"::{
				bet(2048,32768),
				type(int)
			},
			"receiveWindow"::{
				bet(16,128),
				type(int)
			},
			"frameSize"::{
				bet(1024,16384),
				type(int)
			},
			"insertHeader"::type(bool),
			"concurrentStreamsPerConnection"::{
				bet(1,256),
				type(int)
			},
			"enforceTlsRequirements"::type(bool),
			"class"::{
				const("[HTTP2_Profile]"),
				type(str)
			},
			"connectionIdleTimeout"::{
				bet(1,4294967295),
				type(int)
			}
		],
		req["class"]
	},
	def "Pointer_Log_Publisher" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Rewrite_Profile_Uri_Rule" = {
		type(obj),
		properties[
			"server"::{
				type(obj),
				properties[
					"path"::{
						length(1,null),
						type(str)
					},
					"scheme"::type(str),
					"port"::type(str),
					"host"::{
						length(1,null),
						type(str)
					},
					addp(
					|	path
					|	scheme
					|	port
					|	host)::false
				],
				req["path"]
			},
			"client"::{
				type(obj),
				properties[
					"path"::{
						length(1,null),
						type(str)
					},
					"scheme"::type(str),
					"port"::type(str),
					"host"::{
						length(1,null),
						type(str)
					},
					addp(
					|	path
					|	scheme
					|	port
					|	host)::false
				],
				req["path"]
			},
			"type"::{
				type(str),
				enum["both", "request", "response"]
			},
			addp(
			|	server
			|	client
			|	type)::false
		]
	},
	def "Pointer_DNS_Logging_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Monitor_FTP" = properties[
		"mode"::{
			type(str),
			enum["passive", "port"]
		},
		"filename"::type(str),
		"passphrase"::{
			if: true, 
			then: ref: "#/definitions/Secret",
			type(obj),
			properties[
				"allowReuse"::type(bool)
			]
		},
		"username"::type(str)
	],
	def "Policy_Condition_HTTP_Cookie" = {
		allOf[
			properties[
				"event"::{
					type(str),
					enum["proxy-request", "request", "proxy-connect"]
				}
			],
			{
				properties[
					"all"::ref: "#/definitions/Policy_Compare_String",
					"name"::type(str)
				],
				req["all",
					"name"]
			}
		],
		type(obj)
	},
	def "Log_Destination_Splunk" = {
		type(obj),
		properties[
			"forwardTo"::ref: "#/definitions/Pointer_Log_Destination"
		],
		req["forwardTo"]
	},
	def "DOS_Profile_Application_Heavy_URL" = {
		type(obj),
		properties[
			"detectionThreshold"::{
				bet(16,4294967295),
				type(int)
			},
			"excludeList"::{
				type(arr),
				items(;type(str))
			},
			"automaticDetectionEnabled"::type(bool),
			"protectList"::{
				type(arr),
				items(;{
					type(obj),
					properties[
						"threshold"::{
							bet(0,4294967295),
							type(int)
						},
						"url"::type(str),
						addp(
						|	threshold
						|	url)::false
					],
					req["url",
						"threshold"]
				})
			},
			addp(
			|	detectionThreshold
			|	excludeList
			|	automaticDetectionEnabled
			|	protectList)::false
		]
	},
	def "Pointer_Enforcement_Subscriber_Management_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_Enforcement_Interception_Endpoint" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "NAT_Source_Translation_Mapping" = {
		type(obj),
		properties[
			"mode"::{
				type(str),
				enum["address-pooling-paired", "endpoint-independent-mapping", "none"]
			},
			"timeout"::{
				bet(0,2147483647),
				type(int)
			},
			addp(
			|	mode
			|	timeout)::false
		]
	},
	def "DOS_Bad_Actor_Detection_Settings" = {
		type(obj),
		properties[
			"sourceMitigationThreshold"::{
				bet(0,4294967295),
				type(int)
			},
			"sourceDetectionThreshold"::{
				bet(0,4294967295),
				type(int)
			},
			"enabled"::type(bool),
			addp(
			|	sourceMitigationThreshold
			|	sourceDetectionThreshold
			|	enabled)::false
		]
	},
	def "Pointer_IP_Other_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Data_Group_Records_String" = allOf[
		ref: "#/definitions/Data_Group_Records_Base"
	],
	def "SSH_Proxy_Profile_Rule_Action" = {
		type(obj),
		properties[
			"log"::type(bool),
			"control"::{
				type(str),
				enum["allow", "disallow", "terminate", "unspecified"]
			},
			addp(
			|	log
			|	control)::false
		]
	},
	def "SSH_Proxy_Profile" = {
		type(obj),
		properties[
			"sshProfileDefaultActions"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action_Collection",
			"sshProfileAuthInfo"::{
				type(arr),
				items(;ref: "#/definitions/SSH_Proxy_Profile_Auth_Info_Collection")
			},
			"sshProfileRuleSet"::{
				type(arr),
				items(;ref: "#/definitions/SSH_Proxy_Profile_Rule_Collection")
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[SSH_Proxy_Profile]"),
				type(str)
			},
			"timeout"::type(int),
			addp(
			|	sshProfileDefaultActions
			|	sshProfileAuthInfo
			|	sshProfileRuleSet
			|	remark
			|	label
			|	class
			|	timeout)::false
		],
		req["class"]
	},
	def "IP_Other_Profile" = {
		type(obj),
		properties[
			"parentProfile"::ref: "#/definitions/Pointer_IP_Other_Profile",
			"idleTimeout"::if: type(str), 
			then: enum["indefinite", "immediate"], 
			else: {
				bet(0,4294967295),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[IP_Other_Profile]"),
				type(str)
			},
			addp(
			|	parentProfile
			|	idleTimeout
			|	remark
			|	label
			|	class)::false
		],
		req["class"]
	},
	def "SSH_Proxy_Profile_Proxy_Auth_Info" = {
		type(obj),
		properties[
			"privateKey"::{
				if: true, 
				then: ref: "#/definitions/Secret",
				type(obj),
				properties[
					"allowReuse"::type(bool)
				]
			},
			"publicKey"::type(str)
		]
	},
	def "Template_udp" = {
		properties[
			"serviceMain"::ref: "#/definitions/Service_UDP"
		],
		req["serviceMain"]
	},
	def "DNS_Zone_DNS_Express" = {
		properties[
			"allowNotifyFrom"::{
				type(arr),
				items(;type(str))
			},
			"nameserver"::ref: "#/definitions/Pointer_DNS_Nameserver",
			"notifyAction"::{
				type(str),
				enum["consume", "bypass", "repeat"]
			},
			"enabled"::type(bool),
			"verifyNotifyTsig"::type(bool),
			addp(
			|	allowNotifyFrom
			|	nameserver
			|	notifyAction
			|	enabled
			|	verifyNotifyTsig)::false
		],
		req["nameserver"]
	},
	def "Pointer_WAF_Policy" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Application" = {
		allOf[
			if: properties[
				"template"::const("[https]")
			], 
			then: ref: "#/definitions/Template_https",
			if: properties[
				"template"::const("[http]")
			], 
			then: ref: "#/definitions/Template_http",
			if: properties[
				"template"::const("[tcp]")
			], 
			then: ref: "#/definitions/Template_tcp",
			if: properties[
				"template"::const("[udp]")
			], 
			then: ref: "#/definitions/Template_udp",
			if: properties[
				"template"::const("[l4]")
			], 
			then: ref: "#/definitions/Template_l4",
			if: properties[
				"template"::const("[generic]")
			], 
			then: ref: "#/definitions/Template_generic"
		],
		names: {
			pattern("^[A-Za-z][0-9A-Za-z_]*$"),
			length(null,64)
		},
		type(obj),
		properties[
			"template"::type(str),
			"serviceMain"::,
			"enable"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"constants"::ref: "#/definitions/Constants",
			"schemaOverlay"::type(str),
			"class"::{
				const("[Application]"),
				type(str)
			},
			addp(
			|	template
			|	serviceMain
			|	enable
			|	remark
			|	label
			|	constants
			|	schemaOverlay
			|	class)::{
				allOf[
					if: properties[
						"class"::const("[Service_HTTP]")
					], 
					then: ref: "#/definitions/Service_HTTP",
					if: properties[
						"class"::const("[Service_HTTPS]")
					], 
					then: ref: "#/definitions/Service_HTTPS",
					if: properties[
						"class"::const("[Service_TCP]")
					], 
					then: ref: "#/definitions/Service_TCP",
					if: properties[
						"class"::const("[Service_UDP]")
					], 
					then: ref: "#/definitions/Service_UDP",
					if: properties[
						"class"::const("[Service_L4]")
					], 
					then: ref: "#/definitions/Service_L4",
					if: properties[
						"class"::const("[Service_Generic]")
					], 
					then: ref: "#/definitions/Service_Generic",
					if: properties[
						"class"::const("[Service_Address]")
					], 
					then: ref: "#/definitions/Service_Address",
					if: properties[
						"class"::const("[SNAT_Pool]")
					], 
					then: ref: "#/definitions/SNAT_Pool",
					if: properties[
						"class"::const("[iRule]")
					], 
					then: ref: "#/definitions/iRule",
					if: properties[
						"class"::const("[WAF_Policy]")
					], 
					then: ref: "#/definitions/WAF_Policy",
					if: properties[
						"class"::const("[Persist]")
					], 
					then: ref: "#/definitions/Persist",
					if: properties[
						"class"::const("[Pool]")
					], 
					then: ref: "#/definitions/Pool",
					if: properties[
						"class"::const("[Monitor]")
					], 
					then: ref: "#/definitions/Monitor",
					if: properties[
						"class"::const("[TLS_Server]")
					], 
					then: ref: "#/definitions/TLS_Server",
					if: properties[
						"class"::const("[TLS_Client]")
					], 
					then: ref: "#/definitions/TLS_Client",
					if: properties[
						"class"::const("[Certificate]")
					], 
					then: ref: "#/definitions/Certificate",
					if: properties[
						"class"::const("[CA_Bundle]")
					], 
					then: ref: "#/definitions/CA_Bundle",
					if: properties[
						"class"::const("[Certificate_Validator_OCSP]")
					], 
					then: ref: "#/definitions/Certificate_Validator_OCSP",
					if: properties[
						"class"::const("[FIX_Profile]")
					], 
					then: ref: "#/definitions/FIX_Profile",
					if: properties[
						"class"::const("[SIP_Profile]")
					], 
					then: ref: "#/definitions/SIP_Profile",
					if: properties[
						"class"::const("[Analytics_Profile]")
					], 
					then: ref: "#/definitions/Analytics_Profile",
					if: properties[
						"class"::const("[FTP_Profile]")
					], 
					then: ref: "#/definitions/FTP_Profile",
					if: properties[
						"class"::const("[HTTP_Profile]")
					], 
					then: ref: "#/definitions/HTTP_Profile",
					if: properties[
						"class"::const("[HTTP_Compress]")
					], 
					then: ref: "#/definitions/HTTP_Compress",
					if: properties[
						"class"::const("[HTTP2_Profile]")
					], 
					then: ref: "#/definitions/HTTP2_Profile",
					if: properties[
						"class"::const("[Multiplex_Profile]")
					], 
					then: ref: "#/definitions/Multiplex_Profile",
					if: properties[
						"class"::const("[TCP_Profile]")
					], 
					then: ref: "#/definitions/TCP_Profile",
					if: properties[
						"class"::const("[UDP_Profile]")
					], 
					then: ref: "#/definitions/UDP_Profile",
					if: properties[
						"class"::const("[L4_Profile]")
					], 
					then: ref: "#/definitions/L4_Profile",
					if: properties[
						"class"::const("[Classification_Profile]")
					], 
					then: ref: "#/definitions/Classification_Profile",
					if: properties[
						"class"::const("[Radius_Profile]")
					], 
					then: ref: "#/definitions/Radius_Profile",
					if: properties[
						"class"::const("[IP_Other_Profile]")
					], 
					then: ref: "#/definitions/IP_Other_Profile",
					if: properties[
						"class"::const("[Rewrite_Profile]")
					], 
					then: ref: "#/definitions/Rewrite_Profile",
					if: properties[
						"class"::const("[HTTP_Acceleration_Profile]")
					], 
					then: ref: "#/definitions/HTTP_Acceleration_Profile",
					if: properties[
						"class"::const("[Stream_Profile]")
					], 
					then: ref: "#/definitions/Stream_Profile",
					if: properties[
						"class"::const("[Firewall_Address_List]")
					], 
					then: ref: "#/definitions/Firewall_Address_List",
					if: properties[
						"class"::const("[Firewall_Port_List]")
					], 
					then: ref: "#/definitions/Firewall_Port_List",
					if: properties[
						"class"::const("[Firewall_Rule_List]")
					], 
					then: ref: "#/definitions/Firewall_Rule_List",
					if: properties[
						"class"::const("[Firewall_Policy]")
					], 
					then: ref: "#/definitions/Firewall_Policy",
					if: properties[
						"class"::const("[NAT_Policy]")
					], 
					then: ref: "#/definitions/NAT_Policy",
					if: properties[
						"class"::const("[NAT_Source_Translation]")
					], 
					then: ref: "#/definitions/NAT_Source_Translation",
					if: properties[
						"class"::const("[SSH_Proxy_Profile]")
					], 
					then: ref: "#/definitions/SSH_Proxy_Profile",
					if: properties[
						"class"::const("[Data_Group]")
					], 
					then: ref: "#/definitions/Data_Group",
					if: properties[
						"class"::const("[DNS_Cache]")
					], 
					then: ref: "#/definitions/DNS_Cache",
					if: properties[
						"class"::const("[DNS_Profile]")
					], 
					then: ref: "#/definitions/DNS_Profile",
					if: properties[
						"class"::const("[DNS_TSIG_Key]")
					], 
					then: ref: "#/definitions/DNS_TSIG_Key",
					if: properties[
						"class"::const("[DNS_Zone]")
					], 
					then: ref: "#/definitions/DNS_Zone",
					if: properties[
						"class"::const("[DNS_Nameserver]")
					], 
					then: ref: "#/definitions/DNS_Nameserver",
					if: properties[
						"class"::const("[DOS_Profile]")
					], 
					then: ref: "#/definitions/DOS_Profile",
					if: properties[
						"class"::const("[GSLB_Domain]")
					], 
					then: ref: "#/definitions/GSLB_Domain",
					if: properties[
						"class"::const("[GSLB_Monitor]")
					], 
					then: ref: "#/definitions/GSLB_Monitor",
					if: properties[
						"class"::const("[GSLB_Pool]")
					], 
					then: ref: "#/definitions/GSLB_Pool",
					if: properties[
						"class"::const("[GSLB_Server]")
					], 
					then: ref: "#/definitions/GSLB_Server",
					if: properties[
						"class"::const("[GSLB_Data_Center]")
					], 
					then: ref: "#/definitions/GSLB_Data_Center",
					if: properties[
						"class"::const("[GSLB_Prober_Pool]")
					], 
					then: ref: "#/definitions/GSLB_Prober_Pool",
					if: properties[
						"class"::const("[GSLB_Topology_Records]")
					], 
					then: ref: "#/definitions/GSLB_Topology_Records",
					if: properties[
						"class"::const("[GSLB_Topology_Region]")
					], 
					then: ref: "#/definitions/GSLB_Topology_Region",
					if: properties[
						"class"::const("[Security_Log_Profile]")
					], 
					then: ref: "#/definitions/Security_Log_Profile",
					if: properties[
						"class"::const("[Log_Publisher]")
					], 
					then: ref: "#/definitions/Log_Publisher",
					if: properties[
						"class"::const("[Log_Destination]")
					], 
					then: ref: "#/definitions/Log_Destination",
					if: properties[
						"class"::const("[Traffic_Log_Profile]")
					], 
					then: ref: "#/definitions/Traffic_Log_Profile",
					if: properties[
						"class"::const("[Endpoint_Policy]")
					], 
					then: ref: "#/definitions/Endpoint_Policy",
					if: properties[
						"class"::const("[Endpoint_Strategy]")
					], 
					then: ref: "#/definitions/Endpoint_Strategy",
					if: properties[
						"class"::const("[Bandwidth_Control_Policy]")
					], 
					then: ref: "#/definitions/Bandwidth_Control_Policy",
					if: properties[
						"class"::const("[Enforcement_Policy]")
					], 
					then: ref: "#/definitions/Enforcement_Policy",
					if: properties[
						"class"::const("[Enforcement_Diameter_Endpoint_Profile]")
					], 
					then: ref: "#/definitions/Enforcement_Diameter_Endpoint_Profile",
					if: properties[
						"class"::const("[Enforcement_Radius_AAA_Profile]")
					], 
					then: ref: "#/definitions/Enforcement_Radius_AAA_Profile",
					if: properties[
						"class"::const("[Enforcement_Profile]")
					], 
					then: ref: "#/definitions/Enforcement_Profile",
					if: properties[
						"class"::const("[Enforcement_Subscriber_Management_Profile]")
					], 
					then: ref: "#/definitions/Enforcement_Subscriber_Management_Profile",
					if: properties[
						"class"::const("[Enforcement_Listener]")
					], 
					then: ref: "#/definitions/Enforcement_Listener",
					if: properties[
						"class"::const("[Enforcement_Interception_Endpoint]")
					], 
					then: ref: "#/definitions/Enforcement_Interception_Endpoint",
					if: properties[
						"class"::const("[Enforcement_Format_Script]")
					], 
					then: ref: "#/definitions/Enforcement_Format_Script",
					if: properties[
						"class"::const("[Enforcement_Forwarding_Endpoint]")
					], 
					then: ref: "#/definitions/Enforcement_Forwarding_Endpoint",
					if: properties[
						"class"::const("[Enforcement_Service_Chain_Endpoint]")
					], 
					then: ref: "#/definitions/Enforcement_Service_Chain_Endpoint"
				],
				properties[
					"class"::{
						type(str),
						enum["Service_HTTP", "Service_HTTPS", "Service_TCP", "Service_UDP", "Service_L4", "Service_Generic", "Service_Address", "SNAT_Pool", "iRule", "WAF_Policy", "Persist", "Pool", "Monitor", "TLS_Server", "TLS_Client", "Certificate", "CA_Bundle", "Certificate_Validator_OCSP", "FIX_Profile", "SIP_Profile", "Analytics_Profile", "FTP_Profile", "HTTP_Profile", "HTTP_Compress", "HTTP2_Profile", "Multiplex_Profile", "TCP_Profile", "UDP_Profile", "L4_Profile", "Classification_Profile", "Radius_Profile", "IP_Other_Profile", "Rewrite_Profile", "HTTP_Acceleration_Profile", "Stream_Profile", "Firewall_Address_List", "Firewall_Port_List", "Firewall_Rule_List", "Firewall_Policy", "NAT_Policy", "NAT_Source_Translation", "SSH_Proxy_Profile", "Data_Group", "DNS_Cache", "DNS_Profile", "DNS_TSIG_Key", "DNS_Zone", "DNS_Nameserver", "DOS_Profile", "GSLB_Domain", "GSLB_Monitor", "GSLB_Pool", "GSLB_Server", "GSLB_Data_Center", "GSLB_Prober_Pool", "GSLB_Topology_Records", "GSLB_Topology_Region", "Security_Log_Profile", "Log_Publisher", "Log_Destination", "Traffic_Log_Profile", "Endpoint_Policy", "Endpoint_Strategy", "Bandwidth_Control_Policy", "Enforcement_Policy", "Enforcement_Diameter_Endpoint_Profile", "Enforcement_Radius_AAA_Profile", "Enforcement_Profile", "Enforcement_Subscriber_Management_Profile", "Enforcement_Listener", "Enforcement_Interception_Endpoint", "Enforcement_Format_Script", "Enforcement_Forwarding_Endpoint", "Enforcement_Service_Chain_Endpoint"]
					}
				]
			}
		],
		req["class",
			"template"]
	},
	def "Pointer_Enforcement_Forwarding_Endpoint" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Persist_MSRDP" = properties[
		"duration"::{
			bet(0,604800),
			type(int)
		},
		"sessionBroker"::type(bool)
	],
	def "Data_Group" = {
		if: properties[
			"storageType"::const("[internal]")
		], 
		then: {
			allOf[
				if: properties[
					"keyDataType"::const("[string]")
				], 
				then: ref: "#/definitions/Data_Group_Records_String",
				if: properties[
					"keyDataType"::const("[integer]")
				], 
				then: ref: "#/definitions/Data_Group_Records_Integer",
				if: properties[
					"keyDataType"::const("[ip]")
				], 
				then: ref: "#/definitions/Data_Group_Records_IP"
			],
			req["class",
				"keyDataType",
				"records"]
		}, 
		else: {
			oneOf[
				req["class",
					"keyDataType",
					"externalFilePath"],
				req["class",
					"keyDataType",
					"dataGroupFile"]
			],
			not: req["externalFilePath",
				"dataGroupFile"],
			properties[
				"externalFilePath"::type(str),
				"ignoreChanges"::type(bool),
				"dataGroupFile"::ref: "#/definitions/Pointer_Data_Group_File",
				"separator"::type(str)
			]
		},
		type(obj),
		properties[
			"keyDataType"::{
				type(str),
				enum["integer", "ip", "string"]
			},
			"storageType"::{
				type(str),
				enum["internal", "external"]
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Data_Group]"),
				type(str)
			}
		]
	},
	def "Enforcement_Forwarding_Endpoint" = {
		type(obj),
		properties[
			"fallbackPersistenceType"::{
				type(str),
				enum["destination-ip", "disabled", "source-ip"]
			},
			"SNATPool"::ref: "#/definitions/Pointer_SNAT_Pool",
			"portTranslationEnabled"::type(bool),
			"defaultPersistenceType"::{
				type(str),
				enum["destination-ip", "disabled", "hash", "source-ip"]
			},
			"pool"::ref: "#/definitions/Pointer_Pool",
			"remark"::ref: "#/definitions/Remark",
			"persistenceHashSettings"::ref: "#/definitions/Enforcement_Forwarding_Endpoint_Hash_Settings",
			"label"::ref: "#/definitions/Label",
			"sourcePortAction"::{
				type(str),
				enum["change", "preserve", "preserve-strict"]
			},
			"class"::{
				const("[Enforcement_Forwarding_Endpoint]"),
				type(str)
			},
			"addressTranslationEnabled"::type(bool),
			addp(
			|	fallbackPersistenceType
			|	SNATPool
			|	portTranslationEnabled
			|	defaultPersistenceType
			|	pool
			|	remark
			|	persistenceHashSettings
			|	label
			|	sourcePortAction
			|	class
			|	addressTranslationEnabled)::false
		],
		req["class",
			"pool"]
	},
	def "DOS_Profile_Protocol_SIP" = {
		type(obj),
		properties[
			"vectors"::{
				type(arr),
				items(;ref: "#/definitions/DOS_SIP_Vector")
			},
			addp(
			|	vectors)::false
		]
	},
	def "Policy_Action_HTTP_URI" = {
		type(obj),
		properties[
			"replace"::{
				oneOf[
					{
						properties[
							"value"::type(str),
							addp(
							|	value)::false
						],
						req["value"]
					},
					{
						properties[
							"path"::type(str),
							addp(
							|	path)::false
						],
						req["path"]
					},
					{
						properties[
							"queryString"::type(str),
							addp(
							|	queryString)::false
						],
						req["queryString"]
					}
				],
				type(obj)
			},
			"event"::{
				type(str),
				enum["request"]
			}
		],
		req["replace"]
	},
	def "Pointer_Enforcement_Service_Chain_Endpoint" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_SNAT_Pool" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Certificate_Validator_OCSP" = {
		properties[
			"responderUrl"::{
				length(3,null),
				type(str)
			},
			"signingCertificate"::ref: "#/definitions/Pointer_SSL_Certificate",
			"signingHashAlgorithm"::{
				type(str),
				enum["sha1", "sha256"]
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"dnsResolver"::ref: "#/definitions/Pointer_DNS_Resolver",
			"class"::{
				const("[Certificate_Validator_OCSP]"),
				type(str)
			},
			"timeout"::{
				bet(1,300),
				type(int)
			},
			addp(
			|	responderUrl
			|	signingCertificate
			|	signingHashAlgorithm
			|	remark
			|	label
			|	dnsResolver
			|	class
			|	timeout)::false
		],
		req["class"]
	},
	def "Pointer_SSL_CRL_File" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Policy_Condition_SSL_Extension" = {
		allOf[
			properties[
				"event"::{
					type(str),
					enum["ssl-client-hello", "ssl-server-hello"]
				}
			],
			oneOf[
				{
					properties[
						"serverName"::ref: "#/definitions/Policy_Compare_String"
					],
					req["serverName"]
				},
				{
					properties[
						"index"::{
							bet(1,null),
							type(int)
						},
						"npn"::ref: "#/definitions/Policy_Compare_String"
					],
					req["npn"]
				},
				{
					properties[
						"alpn"::ref: "#/definitions/Policy_Compare_String",
						"index"::{
							bet(1,null),
							type(int)
						}
					],
					req["alpn"]
				}
			]
		],
		type(obj)
	},
	def "Pointer_DNS_Listener" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Classification_Profile" = {
		type(obj),
		properties[
			"appDetectionEnabled"::type(bool),
			"iRuleEventEnabled"::type(bool),
			"parentProfile"::ref: "#/definitions/Pointer_Classification_Profile",
			"statisticsPublisher"::ref: "#/definitions/Pointer_Log_Publisher",
			"urlCategorizationEnabled"::type(bool),
			"logPublisher"::ref: "#/definitions/Pointer_Log_Publisher",
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"preset"::ref: "#/definitions/Pointer_Classification_Preset",
			"class"::{
				const("[Classification_Profile]"),
				type(str)
			},
			"statisticsCollectionEnabled"::type(bool),
			"logUnclassifiedDomain"::type(bool),
			addp(
			|	appDetectionEnabled
			|	iRuleEventEnabled
			|	parentProfile
			|	statisticsPublisher
			|	urlCategorizationEnabled
			|	logPublisher
			|	remark
			|	label
			|	preset
			|	class
			|	statisticsCollectionEnabled
			|	logUnclassifiedDomain)::false
		],
		req["class"]
	},
	def "Pointer_Stream_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Security_Log_Profile_Ssh_Proxy" = properties[
		"logClientAuthSuccess"::type(bool),
		"logAllowedChannelAction"::type(bool),
		"logServerAuthSuccess"::type(bool),
		"logClientAuthFail"::type(bool),
		"publisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		"logServerAuthFail"::type(bool),
		"logServerAuthPartial"::type(bool),
		"logClientAuthPartial"::type(bool),
		"logSshTimeout"::type(bool),
		"logNonSshTraffic"::type(bool),
		"logDisallowedChannelAction"::type(bool),
		addp(
		|	logClientAuthSuccess
		|	logAllowedChannelAction
		|	logServerAuthSuccess
		|	logClientAuthFail
		|	publisher
		|	logServerAuthFail
		|	logServerAuthPartial
		|	logClientAuthPartial
		|	logSshTimeout
		|	logNonSshTraffic
		|	logDisallowedChannelAction)::false
	],
	def "Pointer_GSLB_Virtual_Server" = {
		type(obj),
		properties[
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	use)::false
		],
		pro(1,1)
	},
	def "DOS_Profile_Application_Bot_Defense" = {
		type(obj),
		properties[
			"mode"::{
				type(str),
				enum["off", "during-attacks", "always"]
			},
			"gracePeriod"::{
				bet(0,4294967295),
				type(int)
			},
			"blockSuspiscousBrowsers"::type(bool),
			"crossDomainRequests"::{
				type(str),
				enum["allow-all", "validate-bulk", "validate-upon-request"]
			},
			"urlWhitelist"::{
				type(arr),
				items(;type(str))
			},
			"externalDomains"::{
				type(arr),
				items(;type(str))
			},
			"issueCaptchaChallenge"::type(bool),
			"siteDomains"::{
				type(arr),
				items(;type(str))
			},
			addp(
			|	mode
			|	gracePeriod
			|	blockSuspiscousBrowsers
			|	crossDomainRequests
			|	urlWhitelist
			|	externalDomains
			|	issueCaptchaChallenge
			|	siteDomains)::false
		]
	},
	def "Service_L4" = {
		not: req["profileTrafficLog"],
		if: true, 
		then: ref: "#/definitions/Service_L4_Core",
		type(obj),
		properties[
			"persistenceMethods"::{
				type(arr),
				items(;ref: "#/definitions/Basic_Persist")
			},
			"class"::{
				const("[Service_L4]"),
				type(str)
			}
		],
		req["class",
			"virtualPort"]
	},
	def "Service_Address" = {
		type(obj),
		properties[
			"trafficGroup"::type(str),
			"spanningEnabled"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"virtualAddress"::type(str),
			"label"::ref: "#/definitions/Label",
			"arpEnabled"::type(bool),
			"class"::{
				const("[Service_Address]"),
				type(str)
			},
			"icmpEcho"::{
				type(str),
				enum["enable", "disable", "selective"]
			},
			"routeAdvertisement"::{
				type(str),
				enum["enable", "disable", "selective", "always", "any", "all"]
			},
			addp(
			|	trafficGroup
			|	spanningEnabled
			|	remark
			|	virtualAddress
			|	label
			|	arpEnabled
			|	class
			|	icmpEcho
			|	routeAdvertisement)::false
		],
		req["virtualAddress"]
	},
	def "Policy_Condition_HTTP_URI" = {
		allOf[
			properties[
				"event"::{
					type(str),
					enum["request"]
				}
			],
			oneOf[
				{
					properties[
						"path"::ref: "#/definitions/Policy_Compare_String",
						"normalized"::type(bool)
					],
					req["path"]
				},
				{
					properties[
						"scheme"::ref: "#/definitions/Policy_Compare_String",
						"normalized"::type(bool)
					],
					req["scheme"]
				},
				{
					properties[
						"normalized"::type(bool),
						"host"::ref: "#/definitions/Policy_Compare_String"
					],
					req["host"]
				},
				{
					properties[
						"port"::ref: "#/definitions/Policy_Compare_Number",
						"normalized"::type(bool)
					],
					req["port"]
				},
				{
					properties[
						"extension"::ref: "#/definitions/Policy_Compare_String",
						"normalized"::type(bool)
					],
					req["extension"]
				},
				{
					properties[
						"normalized"::type(bool),
						"queryString"::ref: "#/definitions/Policy_Compare_String"
					],
					req["queryString"]
				},
				{
					properties[
						"normalized"::type(bool),
						"name"::type(str),
						"queryParameter"::ref: "#/definitions/Policy_Compare_String"
					],
					req["queryParameter",
						"name"]
				},
				{
					properties[
						"normalized"::type(bool),
						"unnamedQueryParameter"::ref: "#/definitions/Policy_Compare_String",
						"index"::{
							bet(1,null),
							type(int)
						}
					],
					req["unnamedQueryParameter",
						"index"]
				},
				{
					properties[
						"pathSegment"::ref: "#/definitions/Policy_Compare_String",
						"normalized"::type(bool),
						"index"::{
							bet(1,null),
							type(int)
						}
					],
					req["pathSegment",
						"index"]
				},
				{
					properties[
						"all"::ref: "#/definitions/Policy_Compare_String",
						"normalized"::type(bool)
					],
					req["all"]
				}
			]
		],
		type(obj)
	},
	def "Enforcement_Rule_Usage_Radius" = {
		properties[
			"radiusAAAService"::ref: "#/definitions/Pointer_Service"
		],
		req["radiusAAAService"]
	},
	def "Rewrite_Profile_Response_Settings" = {
		type(obj),
		properties[
			"rewriteHeadersEnabled"::type(bool),
			"rewriteContentEnabled"::type(bool),
			addp(
			|	rewriteHeadersEnabled
			|	rewriteContentEnabled)::false
		]
	},
	def "Firewall_Port_List" = {
		anyOf[
			req["ports"],
			req["portLists"]
		],
		type(obj),
		properties[
			"portLists"::{
				betitems(1,null),
				type(arr),
				items(;{
					type(obj),
					properties[
						"bigip"::type(str),
						"use"::{
							length(1,null),
							type(str)
						},
						addp(
						|	bigip
						|	use)::false
					],
					pro(1,1)
				})
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"ports"::{
				betitems(1,null),
				type(arr),
				items(;)
			},
			"class"::{
				const("[Firewall_Port_List]"),
				type(str)
			},
			addp(
			|	portLists
			|	remark
			|	label
			|	ports
			|	class)::false
		],
		req["class"]
	},
	def "FIX_Profile" = {
		type(obj),
		properties[
			"reportLogPublisher"::ref: "#/definitions/Pointer_Log_Publisher",
			"messageLogPublisher"::ref: "#/definitions/Pointer_Log_Publisher",
			"parentProfile"::ref: "#/definitions/Pointer_FIX_Profile",
			"statisticsSampleInterval"::{
				bet(10,4294967295),
				type(int)
			},
			"senderTagMappingList"::{
				type(arr),
				items(;ref: "#/definitions/Sender_Tag_Mapping")
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"errorAction"::{
				type(str),
				enum["dont-forward", "drop-connection"]
			},
			"fullLogonParsingEnabled"::type(bool),
			"responseParsingEnabled"::type(bool),
			"class"::{
				const("[FIX_Profile]"),
				type(str)
			},
			"quickParsingEnabled"::type(bool),
			addp(
			|	reportLogPublisher
			|	messageLogPublisher
			|	parentProfile
			|	statisticsSampleInterval
			|	senderTagMappingList
			|	remark
			|	label
			|	errorAction
			|	fullLogonParsingEnabled
			|	responseParsingEnabled
			|	class
			|	quickParsingEnabled)::false
		],
		req["class"]
	},
	def "Log_Publisher" = {
		type(obj),
		properties[
			"destinations"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Log_Destination")
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Log_Publisher]"),
				type(str)
			}
		],
		req["class",
			"destinations"]
	},
	def "Constants" = {
		names: {
			pattern("^[A-Za-z][0-9A-Za-z_]*$"),
			length(null,64)
		},
		type(obj),
		properties[
			"class"::{
				const("[Constants]"),
				type(str)
			},
			addp(
			|	class)::if: {
				type(obj),
				req["protected",
					"ciphertext"]
			}, 
			then: {
				if: true, 
				then: ref: "#/definitions/JWE",
				properties[
					"allowReuse"::type(bool)
				]
			}
		],
		req["class"]
	},
	def "Sender_Tag_Mapping" = {
		type(obj),
		properties[
			"senderId"::type(str),
			"tagDataGroup"::{
				if: properties[
					"isExternal"::const([true])
				], 
				then: , 
				else: ,
				type(obj),
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					}
				],
				pro(1,2)
			},
			addp(
			|	senderId
			|	tagDataGroup)::false
		],
		req["senderId",
			"tagDataGroup"]
	},
	def "Service_TCP" = {
		if: true, 
		then: ref: "#/definitions/Service_TCP_Core",
		type(obj),
		properties[
			"persistenceMethods"::{
				type(arr),
				items(;ref: "#/definitions/Basic_Persist")
			},
			"profileSIP"::ref: "#/definitions/Pointer_SIP_Profile",
			"profileILX"::ref: "#/definitions/Pointer_ILX_Profile",
			"class"::{
				const("[Service_TCP]"),
				type(str)
			},
			"profileFTP"::ref: "#/definitions/Pointer_FTP_Profile"
		],
		req["class",
			"virtualPort"]
	},
	def "Persist_UIE" = {
		properties[
			"duration"::{
				bet(0,604800),
				type(int)
			},
			"iRule"::if: type(str), 
			then: length(1,null), 
			else: {
				type(obj),
				properties[
					"bigip"::type(str),
					addp(
					|	bigip)::false
				],
				req["bigip"]
			}
		],
		req["iRule"]
	},
	def "Service_Discovery_GCE" = {
		ref: "#/definitions/Service_Discovery_Polling_Core_Tagged",
		if: req["monitors"], 
		then: properties[
			"minimumMonitors"::
		],
		properties[
			"region"::type(str),
			"encodedCredentials"::oneOf[
				{
					length(1,null),
					type(str)
				},
				allOf[
					req["ciphertext"],
					ref: "#/definitions/Secret"
				]
			]
		],
		req["region"]
	},
	def "CA_Bundle" = {
		type(obj),
		properties[
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[CA_Bundle]"),
				type(str)
			},
			"bundle"::if: true, 
			then: ref: "#/definitions/F5string",
			addp(
			|	remark
			|	label
			|	class
			|	bundle)::false
		],
		req["class",
			"bundle"]
	},
	def "Bandwidth_Control_Policy_Category" = {
		type(obj),
		properties[
			"maxBandwidth"::{
				bet(0,1.8446744073709552E19),
				type(int)
			},
			"markIP"::if: type(str), 
			then: const("[pass-through]"), 
			else: {
				bet(0,63),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"maxBandwidthUnit"::{
				type(str),
				enum["bps", "Kbps", "Mbps", "Gbps", "%"]
			},
			"markL2"::if: type(str), 
			then: const("[pass-through]"), 
			else: {
				bet(0,7),
				type(int)
			},
			addp(
			|	maxBandwidth
			|	markIP
			|	remark
			|	maxBandwidthUnit
			|	markL2)::false
		],
		req["maxBandwidth"]
	},
	def "Pointer_Enforcement_Format_Script" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Monitor_May_Adapt" = properties[
		"adaptiveDivergenceMilliseconds"::{
			bet(1,10000),
			type(int)
		},
		"adaptive"::type(bool),
		"adaptiveLimitMilliseconds"::{
			bet(1,10000),
			type(int)
		},
		"adaptiveWindow"::{
			bet(60,1800),
			type(int)
		},
		"adaptiveDivergenceType"::{
			type(str),
			enum["absolute", "relative"]
		},
		"adaptiveDivergencePercentage"::{
			bet(1,500),
			type(int)
		}
	],
	def "NAT_Source_Translation_PortBlockAllocation" = {
		type(obj),
		properties[
			"clientBlockLimit"::{
				bet(0,2147483647),
				type(int)
			},
			"blockIdleTimeout"::{
				bet(0,2147483647),
				type(int)
			},
			"blockLifetime"::{
				bet(0,2147483647),
				type(int)
			},
			"blockSize"::{
				bet(0,2147483647),
				type(int)
			},
			"zombieTimeout"::{
				bet(0,2147483647),
				type(int)
			},
			addp(
			|	clientBlockLimit
			|	blockIdleTimeout
			|	blockLifetime
			|	blockSize
			|	zombieTimeout)::false
		]
	},
	def "Log_Destination" = {
		if: properties[
			"type"::const("[remote-syslog]")
		], 
		then: ref: "#/definitions/Log_Destination_Remote_Syslog", 
		else: if: properties[
			"type"::const("[remote-high-speed-log]")
		], 
		then: ref: "#/definitions/Log_Destination_Remote_High_Speed_Log", 
		else: if: properties[
			"type"::const("[splunk]")
		], 
		then: ref: "#/definitions/Log_Destination_Splunk",
		type(obj),
		properties[
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"type"::{
				type(str),
				enum["remote-syslog", "remote-high-speed-log", "splunk"]
			},
			"class"::{
				const("[Log_Destination]"),
				type(str)
			}
		],
		req["class",
			"type"]
	},
	def "Enforcement_Policy" = {
		type(obj),
		properties[
			"enable"::type(bool),
			"allTransactions"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"rules"::{
				type(arr),
				items(;ref: "#/definitions/Enforcement_Rule")
			},
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Enforcement_Policy]"),
				type(str)
			},
			addp(
			|	enable
			|	allTransactions
			|	remark
			|	rules
			|	label
			|	class)::false
		],
		req["class"]
	},
	def "Monitor_LDAP" = properties[
		"filter"::type(str),
		"mandatoryAttributes"::type(bool),
		"chaseReferrals"::type(bool),
		"security"::{
			type(str),
			enum["none", "ssl", "tls"]
		},
		"passphrase"::{
			if: true, 
			then: ref: "#/definitions/Secret",
			type(obj),
			properties[
				"allowReuse"::type(bool)
			]
		},
		"username"::type(str),
		"base"::type(str)
	],
	def "GSLB_Monitor_HTTP" = properties[
		"receive"::type(str),
		"reverseEnabled"::type(bool),
		"send"::type(str)
	],
	def "Security_Log_Profile_Bot_Defense" = properties[
		"logBotSignatureMatchedRequests"::type(bool),
		"logIllegalRequests"::type(bool),
		"logChallengedRequests"::type(bool),
		"logCaptchaChallengedRequests"::type(bool),
		"logLegalRequests"::type(bool),
		"localPublisher"::ref: "#/definitions/Pointer_Log_Publisher",
		"remotePublisher"::ref: "#/definitions/Pointer_Log_Publisher",
		addp(
		|	logBotSignatureMatchedRequests
		|	logIllegalRequests
		|	logChallengedRequests
		|	logCaptchaChallengedRequests
		|	logLegalRequests
		|	localPublisher
		|	remotePublisher)::false
	],
	def "Radius_Profile" = {
		if: , 
		then: properties[
			"protocolProfile"::,
			"subscriberDiscoveryEnabled"::
		],
		type(obj),
		properties[
			"protocolProfile"::ref: "#/definitions/Pointer_Enforcement_Protocol_Profile_Radius",
			"subscriberDiscoveryEnabled"::type(bool),
			"persistAttribute"::oneOf[
				{
					bet(1,255),
					type(int)
				},
				{
					type(str),
					enum["none", "User-Name", "User-Password", "NAS-IP-Address", "NAS-Port", "Service-Type", "Framed-Protocol", "Framed-IP-Address", "Framed-IP-Netmask", "Framed-Routing", "Filter-Id", "Framed-MTU", "Framed-Compression", "Login-IP-Host", "Login-Service", "Login-TCP-Port", "Reply-Message", "Callback-Number", "Callback-Id", "Framed-Route", "Framed-IPX-Network", "State", "Class", "Vendor-Specific", "Session-Timeout", "Idle-Timeout", "Termination-Action", "Called-Station-Id", "Calling-Station-Id", "NAS-Identifier", "Proxy-State", "Login-LAT-Service", "Login-LAT-Node", "Login-LAT-Group", "Framed-AppleTalk-Link", "Framed-AppleTalk-Network", "Framed-AppleTalk-Zone", "CHAP-Challenge", "NAS-Port-Type", "Port-Limit", "Login-LAT-Port"]
				}
			],
			"parentProfile"::ref: "#/definitions/Pointer_Radius_Profile",
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Radius_Profile]"),
				type(str)
			},
			addp(
			|	protocolProfile
			|	subscriberDiscoveryEnabled
			|	persistAttribute
			|	parentProfile
			|	remark
			|	label
			|	class)::false
		],
		req["class"]
	},
	def "Persist" = {
		allOf[
			if: properties[
				"persistenceMethod"::const("[cookie]")
			], 
			then: ref: "#/definitions/Persist_Cookie",
			if: properties[
				"persistenceMethod"::enum["destination-address", "source-address"]
			], 
			then: ref: "#/definitions/Persist_Addr",
			if: properties[
				"persistenceMethod"::const("[hash]")
			], 
			then: ref: "#/definitions/Persist_Hash",
			if: properties[
				"persistenceMethod"::const("[msrdp]")
			], 
			then: ref: "#/definitions/Persist_MSRDP",
			if: properties[
				"persistenceMethod"::const("[sip-info]")
			], 
			then: ref: "#/definitions/Persist_SIP",
			if: properties[
				"persistenceMethod"::const("[tls-session-id]")
			], 
			then: ref: "#/definitions/Persist_TLS_Session",
			if: properties[
				"persistenceMethod"::const("[universal]")
			], 
			then: ref: "#/definitions/Persist_UIE"
		],
		type(obj),
		properties[
			"mirror"::type(bool),
			"persistenceMethod"::{
				type(str),
				enum["cookie", "destination-address", "hash", "msrdp", "sip-info", "source-address", "tls-session-id", "universal"]
			},
			"matchAcrossVirtualAddresses"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"overrideConnectionLimit"::type(bool),
			"class"::{
				const("[Persist]"),
				type(str)
			},
			"matchAcrossPools"::type(bool),
			"matchAcrossVirtualPorts"::type(bool)
		],
		req["class",
			"persistenceMethod"]
	},
	def "Enforcement_Rule_Usage_Reporting_Volume" = properties[
		"total"::{
			bet(0,null),
			type(int)
		},
		"downlink"::{
			bet(0,null),
			type(int)
		},
		"uplink"::{
			bet(0,null),
			type(int)
		},
		addp(
		|	total
		|	downlink
		|	uplink)::false
	],
	def "Pointer_Classification_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Service_Discovery_AWS" = {
		ref: "#/definitions/Service_Discovery_Polling_Core_Tagged",
		if: req["monitors"], 
		then: properties[
			"minimumMonitors"::
		],
		properties[
			"accessKeyId"::{
				length(1,null),
				type(str)
			},
			"secretAccessKey"::oneOf[
				{
					length(1,null),
					type(str)
				},
				allOf[
					req["ciphertext"],
					ref: "#/definitions/Secret"
				]
			],
			"roleARN"::{
				length(1,null),
				type(str)
			},
			"externalId"::{
				length(1,null),
				type(str)
			},
			"region"::type(str)
		],
		req["region"]
	},
	def "DOS_Profile_Application_Stress_Based_Detection" = properties[
		"deEscalationPeriod"::{
			bet(0,86400),
			type(int)
		},
		"operationMode"::{
			type(str),
			enum["off", "transparent", "blocking"]
		},
		"site"::ref: "#/definitions/DOS_Profile_Application_Detection_Site",
		"escalationPeriod"::{
			bet(1,3600),
			type(int)
		},
		"sourceIP"::ref: "#/definitions/DOS_Profile_Application_Detection_IP",
		"badActor"::ref: "#/definitions/DOS_Profile_Application_Stress_Based_Detection_Bad_Actor",
		"thresholdsMode"::{
			type(str),
			enum["manual", "automatic"]
		},
		"deviceID"::ref: "#/definitions/DOS_Profile_Application_Detection_Device",
		"url"::ref: "#/definitions/DOS_Profile_Application_Detection_URL",
		"geolocation"::ref: "#/definitions/DOS_Profile_Application_Detection_Geolocation",
		addp(
		|	deEscalationPeriod
		|	operationMode
		|	site
		|	escalationPeriod
		|	sourceIP
		|	badActor
		|	thresholdsMode
		|	deviceID
		|	url
		|	geolocation)::false
	],
	def "Pointer_DNS_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Security_Log_Profile_Application" = properties[
		"guaranteeResponseLoggingEnabled"::type(bool),
		"maxRequestSize"::{
			bet(1,2048),
			type(int)
		},
		"localStorage"::type(bool),
		"storageFormat"::anyOf[
			{
				length(1,null),
				type(str)
			},
			{
				type(obj),
				properties[
					"delimiter"::{
						length(1,null),
						type(str)
					},
					"fields"::{
						type(arr),
						items(;{
							type(str),
							enum["attack_type", "avr_id", "blocking_exception_reason", "captcha_result", "client_type", "date_time", "dest_ip", "dest_port", "device_id", "fragment", "geo_location", "headers", "http_class_name", "ip_address_intelligence", "ip_client", "ip_with_route_domain", "is_truncated", "logic_result", "management_ip_address", "management_ip_address_2", "method", "mobile_application_name", "mobile_application_version", "password", "policy_apply_date", "policy_name", "protocol", "query_string", "request", "request_status", "response", "response_code", "route_domain", "salt", "session_id", "severity", "sig_ids", "sig_names", "sig_set_names", "slot_number", "src_port", "staged_sig_names", "staged_sig_set_names", "staged_threat_campaign_names", "sub_violations", "support_id", "threat_campaign_names", "unit_hostname", "uri", "username", "violation_details", "violation_rating", "violations", "virus_name", "websocket_direction", "websocket_message_type", "x_forwarded_for_header_value"]
						})
					},
					addp(
					|	delimiter
					|	fields)::false
				],
				req["fields"]
			}
		],
		"responseLogging"::{
			type(str),
			enum["none", "illegal", "all"]
		},
		"maxEntryLength"::{
			type(str),
			enum["1k", "2k", "10k", "64k"]
		},
		"maxHeaderSize"::{
			bet(1,2048),
			type(int)
		},
		"storageFilter"::{
			type(obj),
			properties[
				"requestContains"::{
					type(obj),
					properties[
						"searchIn"::{
							type(str),
							enum["search-in-headers", "search-in-post-data", "search-in-query-string", "search-in-request", "search-in-uri"]
						},
						"value"::{
							length(1,null),
							type(str)
						},
						addp(
						|	searchIn
						|	value)::false
					],
					req["searchIn",
						"value"]
				},
				"responseCodes"::{
					type(arr),
					items(;{
						type(str),
						enum["100", "101", "102", "200", "201", "202", "203", "204", "205", "206", "207", "300", "301", "302", "303", "304", "305", "306", "307", "400", "401", "402", "403", "404", "405", "406", "407", "408", "409", "410", "411", "412", "413", "414", "415", "416", "417", "422", "423", "424", "500", "501", "502", "503", "504", "505", "507", "510"]
					})
				},
				"loginResults"::{
					type(arr),
					items(;{
						type(str),
						enum["login-result-successful", "login-result-failed", "login-result-unknown"]
					})
				},
				"requestType"::{
					type(str),
					enum["all", "illegal", "illegal-including-staged-signatures"]
				},
				"logicalOperation"::{
					type(str),
					enum["and", "or"]
				},
				"httpMethods"::{
					type(arr),
					items(;{
						type(str),
						enum["ACL", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "MERGE", "MKCOL", "MKWORKSPACE", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POLL", "POST", "PROPFIND", "PROPPATCH", "PUT", "REPORT", "RPC_IN_DATA", "RPC_OUT_DATA", "SEARCH", "SUBSCRIBE", "TRACE", "TRACK", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "VERSION_CONTROL", "X-MS-ENUMATTS"]
					})
				},
				"protocols"::{
					type(arr),
					items(;{
						type(str),
						enum["http", "https", "ws", "wss"]
					})
				},
				addp(
				|	requestContains
				|	responseCodes
				|	loginResults
				|	requestType
				|	logicalOperation
				|	httpMethods
				|	protocols)::false
			]
		},
		"guaranteeLoggingEnabled"::type(bool),
		"maxQuerySize"::{
			bet(1,2048),
			type(int)
		},
		"protocol"::{
			type(str),
			enum["udp", "tcp", "tcp-rfc3195"]
		},
		"servers"::{
			type(arr),
			items(;{
				type(obj),
				properties[
					"address"::type(str),
					"port"::type(str),
					addp(
					|	address
					|	port)::false
				],
				req["address",
					"port"]
			})
		},
		"reportAnomaliesEnabled"::type(bool),
		"remoteStorage"::{
			type(str),
			enum["remote", "splunk", "arcsight", "bigiq"]
		},
		"facility"::{
			type(str),
			enum["local0", "local1", "local2", "local3", "local4", "local5", "local6", "local7"]
		},
		addp(
		|	guaranteeResponseLoggingEnabled
		|	maxRequestSize
		|	localStorage
		|	storageFormat
		|	responseLogging
		|	maxEntryLength
		|	maxHeaderSize
		|	storageFilter
		|	guaranteeLoggingEnabled
		|	maxQuerySize
		|	protocol
		|	servers
		|	reportAnomaliesEnabled
		|	remoteStorage
		|	facility)::false
	],
	def "DOS_Profile_Application_Rate_Based_Detection" = properties[
		"deEscalationPeriod"::{
			bet(0,86400),
			type(int)
		},
		"operationMode"::{
			type(str),
			enum["off", "transparent", "blocking"]
		},
		"site"::ref: "#/definitions/DOS_Profile_Application_Detection_Site",
		"escalationPeriod"::{
			bet(1,3600),
			type(int)
		},
		"sourceIP"::ref: "#/definitions/DOS_Profile_Application_Detection_IP",
		"thresholdsMode"::{
			type(str),
			enum["manual", "automatic"]
		},
		"deviceID"::ref: "#/definitions/DOS_Profile_Application_Detection_Device",
		"url"::ref: "#/definitions/DOS_Profile_Application_Detection_URL",
		"geolocation"::ref: "#/definitions/DOS_Profile_Application_Detection_Geolocation",
		addp(
		|	deEscalationPeriod
		|	operationMode
		|	site
		|	escalationPeriod
		|	sourceIP
		|	thresholdsMode
		|	deviceID
		|	url
		|	geolocation)::false
	],
	def "Rewrite_Profile" = {
		type(obj),
		properties[
			"setCookieRules"::{
				type(arr),
				items(;ref: "#/definitions/Rewrite_Profile_Set_Cookie_Rule")
			},
			"responseSettings"::ref: "#/definitions/Rewrite_Profile_Response_Settings",
			"requestSettings"::ref: "#/definitions/Rewrite_Profile_Request_Settings",
			"certificate"::type(str),
			"remark"::ref: "#/definitions/Remark",
			"splitTunnelingEnabled"::type(bool),
			"label"::ref: "#/definitions/Label",
			"bypassList"::{
				type(arr),
				items(;{
					length(1,null),
					type(str)
				})
			},
			"javaSignKeyPassphrase"::{
				if: true, 
				then: ref: "#/definitions/Secret",
				type(obj),
				properties[
					"allowReuse"::type(bool)
				]
			},
			"rewriteList"::{
				type(arr),
				items(;{
					length(1,null),
					type(str)
				})
			},
			"locationSpecificEnabled"::type(bool),
			"rewriteMode"::{
				type(str),
				enum["portal", "uri-translation"]
			},
			"clientCachingType"::{
				type(str),
				enum["cache-all", "cache-css-js", "cache-img-css-js", "no-cache"]
			},
			"javaCaFile"::ref: "#/definitions/Pointer_CA_Bundle",
			"uriRules"::{
				type(arr),
				items(;ref: "#/definitions/Rewrite_Profile_Uri_Rule")
			},
			"class"::{
				const("[Rewrite_Profile]"),
				type(str)
			},
			addp(
			|	setCookieRules
			|	responseSettings
			|	requestSettings
			|	certificate
			|	remark
			|	splitTunnelingEnabled
			|	label
			|	bypassList
			|	javaSignKeyPassphrase
			|	rewriteList
			|	locationSpecificEnabled
			|	rewriteMode
			|	clientCachingType
			|	javaCaFile
			|	uriRules
			|	class)::false
		],
		req["class"]
	},
	def "NAT_Rule_Source" = {
		type(obj),
		properties[
			"addressLists"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_Firewall_Address_List")
			},
			"portLists"::{
				type(arr),
				items(;{
					type(obj),
					properties[
						"bigip"::type(str),
						"use"::{
							length(1,null),
							type(str)
						},
						addp(
						|	bigip
						|	use)::false
					],
					pro(1,1)
				})
			},
			addp(
			|	addressLists
			|	portLists)::false
		]
	},
	def "DOS_Profile" = {
		type(obj),
		properties[
			"application"::ref: "#/definitions/DOS_Profile_Application",
			"applicationWhitelist"::ref: "#/definitions/Pointer_Firewall_Address_List",
			"protocolDNS"::ref: "#/definitions/DOS_Profile_Protocol_DNS",
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"protocolSIP"::ref: "#/definitions/DOS_Profile_Protocol_SIP",
			"whitelist"::ref: "#/definitions/Pointer_Firewall_Address_List",
			"class"::{
				const("[DOS_Profile]"),
				type(str)
			},
			"network"::ref: "#/definitions/DOS_Profile_Network",
			addp(
			|	application
			|	applicationWhitelist
			|	protocolDNS
			|	remark
			|	label
			|	protocolSIP
			|	whitelist
			|	class
			|	network)::false
		]
	},
	def "Service_Discovery_Azure" = {
		ref: "#/definitions/Service_Discovery_Polling_Core_Tagged",
		if: req["monitors"], 
		then: properties[
			"minimumMonitors"::
		],
		properties[
			"resourceGroup"::type(str),
			"environment"::type(str),
			"directoryId"::type(str),
			"subscriptionId"::type(str),
			"applicationId"::type(str),
			"apiAccessKey"::oneOf[
				{
					length(1,null),
					type(str)
				},
				allOf[
					req["ciphertext"],
					ref: "#/definitions/Secret"
				]
			]
		],
		req["resourceGroup",
			"subscriptionId",
			"directoryId",
			"applicationId",
			"apiAccessKey"]
	},
	def "GSLB_Monitor_HTTPS" = allOf[
		properties[
			"clientCertificate"::{
				length(1,null),
				type(str)
			},
			"ciphers"::type(str)
		],
		ref: "#/definitions/GSLB_Monitor_HTTP"
	],
	def "Analytics_Profile" = {
		type(obj),
		properties[
			"collectResponseCode"::type(bool),
			"collectMaxTpsAndThroughput"::type(bool),
			"collectUserAgent"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"collectOsAndBrowser"::type(bool),
			"collectUrl"::type(bool),
			"collectMethod"::type(bool),
			"collectUserSession"::type(bool),
			"collectClientSideStatistics"::type(bool),
			"capturedTrafficInternalLogging"::type(bool),
			"externalLoggingPublisher"::ref: "#/definitions/Pointer_Log_Publisher",
			"collectedStatsExternalLogging"::type(bool),
			"class"::{
				const("[Analytics_Profile]"),
				type(str)
			},
			"sessionCookieSecurity"::{
				type(str),
				enum["always-secure", "never-secure", "ssl-only"]
			},
			"capturedTrafficExternalLogging"::type(bool),
			"notificationEmailAddresses"::{
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"subnetsForStatCollection"::{
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"countriesForStatCollection"::{
				type(arr),
				items(;ref: "#/definitions/Enum_Country_Analytics")
			},
			"collectedStatsInternalLogging"::type(bool),
			"label"::ref: "#/definitions/Label",
			"collectPageLoadTime"::type(bool),
			"publishIruleStatistics"::type(bool),
			"collectGeo"::type(bool),
			"collectIp"::type(bool),
			"collectSubnet"::type(bool),
			"sessionTimeoutMinutes"::{
				mof(5),
				bet(5,60),
				type(int)
			},
			"notificationBySyslog"::type(bool),
			"notificationBySnmp"::type(bool),
			"urlsForStatCollection"::{
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"captureFilter"::ref: "#/definitions/Capture_Filter",
			"notificationByEmail"::type(bool),
			addp(
			|	collectResponseCode
			|	collectMaxTpsAndThroughput
			|	collectUserAgent
			|	remark
			|	collectOsAndBrowser
			|	collectUrl
			|	collectMethod
			|	collectUserSession
			|	collectClientSideStatistics
			|	capturedTrafficInternalLogging
			|	externalLoggingPublisher
			|	collectedStatsExternalLogging
			|	class
			|	sessionCookieSecurity
			|	capturedTrafficExternalLogging
			|	notificationEmailAddresses
			|	subnetsForStatCollection
			|	countriesForStatCollection
			|	collectedStatsInternalLogging
			|	label
			|	collectPageLoadTime
			|	publishIruleStatistics
			|	collectGeo
			|	collectIp
			|	collectSubnet
			|	sessionTimeoutMinutes
			|	notificationBySyslog
			|	notificationBySnmp
			|	urlsForStatCollection
			|	captureFilter
			|	notificationByEmail)::false
		],
		req["class"]
	},
	def "Include" = properties[
		"include"::oneOf[
			type(str),
			{
				type(arr),
				items(;type(str))
			}
		]
	],
	def "Enforcement_Rule_Classification_Filter" = {
		oneOf[
			req["application"],
			req["category"]
		],
		properties[
			"application"::ref: "#/definitions/Pointer_Classification_Application",
			"name"::type(str),
			"category"::ref: "#/definitions/Pointer_Classification_Category",
			"invertMatch"::type(bool),
			addp(
			|	application
			|	name
			|	category
			|	invertMatch)::false
		],
		req["name"]
	},
	def "DOS_Profile_Protocol_DNS" = {
		type(obj),
		properties[
			"vectors"::{
				type(arr),
				items(;ref: "#/definitions/DOS_DNS_Vector")
			},
			addp(
			|	vectors)::false
		]
	},
	def "Enforcement_Rule_QOS" = {
		type(obj),
		properties[
			"category"::type(str),
			"policy"::ref: "#/definitions/Pointer_Bandwidth_Control_Policy",
			addp(
			|	category
			|	policy)::false
		],
		req["policy"]
	},
	def "Pointer_GSLB_Pool_Member_A" = {
		type(obj),
		properties[
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	use)::false
		],
		pro(1,1)
	},
	def "DOS_SIP_Vector" = {
		type(obj),
		properties[
			"rateIncreaseThreshold"::{
				bet(0,4294967295),
				type(int)
			},
			"rateLimit"::{
				bet(0,4294967295),
				type(int)
			},
			"thresholdMode"::{
				type(str),
				enum["manual", "stress-based-mitigation", "fully-automatic"]
			},
			"autoAttackCeiling"::{
				bet(0,4294967295),
				type(int)
			},
			"badActorSettings"::ref: "#/definitions/DOS_Bad_Actor_Detection_Settings",
			"simulateAutoThresholdEnabled"::type(bool),
			"autoAttackFloor"::{
				bet(0,4294967295),
				type(int)
			},
			"state"::{
				type(str),
				enum["disabled", "learn-only", "detect-only", "mitigate"]
			},
			"type"::{
				type(str),
				enum["ack", "cancel", "message", "options", "prack", "register", "bye", "invite", "notify", "other", "publish", "subscribe", "uri-limit", "malformed"]
			},
			"rateThreshold"::{
				bet(0,4294967295),
				type(int)
			},
			"autoBlacklistSettings"::ref: "#/definitions/DOS_Auto_Blacklist_Settings",
			addp(
			|	rateIncreaseThreshold
			|	rateLimit
			|	thresholdMode
			|	autoAttackCeiling
			|	badActorSettings
			|	simulateAutoThresholdEnabled
			|	autoAttackFloor
			|	state
			|	type
			|	rateThreshold
			|	autoBlacklistSettings)::false
		],
		req["type"]
	},
	def "Policy_Action_Client_SSL" = {
		type(obj),
		properties[
			"event"::{
				type(str),
				enum["client-accepted", "proxy-request", "request", "proxy-connect", "proxy-response", "server-connected"]
			},
			"enabled"::type(bool)
		]
	},
	def "F5string" = if: not: type(obj), 
	then: type(str), 
	else: properties[
		"bigip"::type(str),
		"base64"::type(str),
		"text"::type(str),
		"url"::{
			length(3,null),
			type(str)
		},
		"copyFrom"::type(str),
		addp(
		|	bigip
		|	base64
		|	text
		|	url
		|	copyFrom)::false
	],
	def "Pointer_GSLB_Domain_CNAME" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_DNS_Security_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Pointer_GSLB_Pool_CNAME" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_DNS_Resolver" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Security_Log_Profile_Protocol_Sip" = properties[
		"logRedirectedResponses"::type(bool),
		"logDroppedRequests"::type(bool),
		"logGlobalFailures"::type(bool),
		"logMalformedRequests"::type(bool),
		"logRequestFailures"::type(bool),
		"storageFormat"::anyOf[
			{
				length(1,null),
				type(str)
			},
			{
				type(obj),
				properties[
					"delimiter"::type(str),
					"fields"::{
						type(arr),
						items(;{
							type(str),
							enum["action", "context-name", "date-time", "dest-ip", "dest-port", "sip-method-type", "sip-caller", "sip-callee", "src-ip", "src-port", "vlan", "route-domain"]
						})
					},
					addp(
					|	delimiter
					|	fields)::false
				],
				req["fields"]
			}
		],
		"publisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		"logServerErrors"::type(bool),
		addp(
		|	logRedirectedResponses
		|	logDroppedRequests
		|	logGlobalFailures
		|	logMalformedRequests
		|	logRequestFailures
		|	storageFormat
		|	publisher
		|	logServerErrors)::false
	],
	def "TLS_Client" = {
		type(obj),
		properties[
			"ignoreExpired"::type(bool),
			"clientCertificate"::type(str),
			"ldapStartTLS"::{
				type(str),
				enum["none", "allow", "require"]
			},
			"sendSNI"::type(str),
			"serverName"::type(str),
			"allowExpiredCRL"::type(bool),
			"c3dCertificateAuthority"::type(str),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"validateCertificate"::type(bool),
			"c3dCertificateLifespan"::{
				bet(0,8760),
				type(int)
			},
			"c3dEnabled"::type(bool),
			"authenticationFrequency"::{
				type(str),
				enum["one-time", "every-time"]
			},
			"c3dCertificateExtensions"::{
				type(arr),
				items(;{
					type(str),
					enum["basic-constraints", "extended-key-usage", "key-usage", "subject-alternative-name"]
				})
			},
			"trustCA"::if: not: type(obj), 
			then: {
				type(str),
				enum["generic", "none"]
			}, 
			else: properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			"sessionTickets"::type(bool),
			"ignoreUntrusted"::type(bool),
			"ciphers"::type(str),
			"class"::{
				const("[TLS_Client]"),
				type(str)
			},
			"crlFile"::ref: "#/definitions/Pointer_SSL_CRL_File",
			addp(
			|	ignoreExpired
			|	clientCertificate
			|	ldapStartTLS
			|	sendSNI
			|	serverName
			|	allowExpiredCRL
			|	c3dCertificateAuthority
			|	remark
			|	label
			|	validateCertificate
			|	c3dCertificateLifespan
			|	c3dEnabled
			|	authenticationFrequency
			|	c3dCertificateExtensions
			|	trustCA
			|	sessionTickets
			|	ignoreUntrusted
			|	ciphers
			|	class
			|	crlFile)::false
		],
		req["class"]
	},
	def "Pointer_DNS_Cache" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "AS3_Array" = {
		betitems(1,null),
		type(arr),
		items(;ref: "#/definitions/AS3")
	},
	def "Persist_Hash" = properties[
		"duration"::{
			bet(0,604800),
			type(int)
		},
		"count"::{
			bet(0,65535),
			type(int)
		},
		"startPattern"::type(str),
		"iRule"::if: type(str), 
		then: length(1,null), 
		else: {
			type(obj),
			properties[
				"bigip"::type(str),
				addp(
				|	bigip)::false
			],
			req["bigip"]
		},
		"bufferLimit"::{
			bet(0,65535),
			type(int)
		},
		"endPattern"::type(str),
		"hashAlgorithm"::{
			type(str),
			enum["carp", "default"]
		},
		"startAt"::{
			bet(0,65535),
			type(int)
		}
	],
	def "Service_L4_Core" = {
		if: true, 
		then: ref: "#/definitions/Service_Core",
		type(obj),
		properties[
			"profileL4"::if: not: type(obj), 
			then: {
				type(str),
				enum["basic"]
			}, 
			else: ref: "#/definitions/Pointer_L4_Profile",
			"layer4"::{
				type(str),
				enum["any", "tcp", "udp", "3pc", "a/n", "ah", "argus", "aris", "ax.25", "bbn-rcc", "bna", "br-sat-mon", "cbt", "cftp", "chaos", "compaq-peer", "cphb", "cpnx", "crdup", "crtp", "dccp", "dcn", "ddp", "ddx", "dgp", "dsr", "egp", "eigrp", "emcon", "encap", "esp", "etherip", "fc", "fire", "ggp", "gmtp", "gre", "hip", "hmp", "hopopt", "i-nlsp", "iatp", "icmp", "idpr", "idpr-cmtp", "idrp", "ifmp", "igmp", "igp", "il", "ip", "ipcomp", "ipcv", "ipencap", "ipip", "iplt", "ippc", "ipv6", "ipv6-auth", "ipv6-crypt", "ipv6-frag", "ipv6-icmp", "ipv6-nonxt", "ipv6-opts", "ipv6-route", "ipx-in-ip", "irtp", "isis", "iso-ip", "iso-tp4", "kryptolan", "l2tp", "larp", "leaf-1", "leaf-2", "manet", "merit-inp", "mfe-nsp", "micp", "mobile", "mpls-in-ip", "mtp", "mux", "narp", "netblt", "nsfnet-igp", "nvp", "ospf", "pgm", "pim", "pipe", "pnni", "prm", "ptp", "pup", "pvp", "qnx", "rdp", "rsvp", "rsvp-e2e-ignore", "rvd", "sat-expak", "sat-mon", "scc-sp", "scps", "sctp", "sdrp", "secure-vmtp", "shim6", "skip", "sm", "smp", "snp", "sprite-rpc", "sps", "srp", "sscopmce", "st", "stp", "sun-nd", "swipe", "tcf", "tlsp", "tp++", "trunk-1", "trunk-2", "ttp", "udplite", "uti", "vines", "visa", "vmtp", "vrrp", "wb-expak", "wb-mon", "wesp", "wsn", "xnet", "xns-idp", "xtp"]
			},
			"profileFIX"::ref: "#/definitions/Pointer_FIX_Profile",
			"virtualPort"::{
				bet(0,65535),
				type(int)
			}
		]
	},
	def "Log_Destination_Remote_High_Speed_Log" = {
		type(obj),
		properties[
			"protocol"::{
				type(str),
				enum["tcp", "udp"]
			},
			"pool"::ref: "#/definitions/Pointer_Pool",
			"distribution"::{
				type(str),
				enum["adaptive", "balanced", "replicated"]
			}
		],
		req["pool"]
	},
	def "Monitor_SIP" = properties[
		"request"::type(str),
		"headers"::type(str),
		"protocol"::{
			type(str),
			enum["sips", "tcp", "tls", "udp"]
		},
		"codesUp"::{
			uniqueItems,
			type(arr),
			items(;{
				bet(0,null),
				type(int)
			})
		},
		"clientCertificate"::{
			length(1,null),
			type(str)
		},
		"ciphers"::type(str),
		"codesDown"::{
			uniqueItems,
			type(arr),
			items(;{
				bet(0,null),
				type(int)
			})
		}
	],
	def "rootdef" = {
		if: type(obj), 
		then: if: req["class"], 
		then: oneOf[
			ref: "#/$defs/AS3",
			ref: "#/$defs/ADC"
		], 
		else: ref: "#/$defs/AS3", 
		else: oneOf[
			ref: "#/$defs/AS3_Patch_Body",
			ref: "#/$defs/AS3_Array",
			ref: "#/$defs/ADC_Array"
		],
		properties[
			"declaration"::{
				names: {
					pattern("^[A-Za-z][0-9A-Za-z_]*$"),
					length(null,64)
				},
				type(obj),
				properties[
					"schemaVersion"::{
						type(str),
						enum["3.13.0", "3.12.0", "3.11.0", "3.10.0", "3.9.0", "3.8.0", "3.7.0", "3.6.0", "3.5.0", "3.4.0", "3.3.0", "3.2.0", "3.1.0", "3.0.0"]
					},
					"controls"::{
						type(obj),
						properties[
							"trace"::type(bool),
							"archiveTimestamp"::type(str),
							"logLevel"::{
								type(str),
								enum["emergency", "alert", "critical", "error", "warning", "notice", "info", "debug"]
							},
							"class"::{
								enum["Controls"],
								type(str)
							},
							"archiveId"::,
							addp(
							|	trace
							|	archiveTimestamp
							|	logLevel
							|	class
							|	archiveId)::false
						]
					},
					"updateMode"::{
						type(str),
						enum["complete", "selective"]
					},
					"remark"::type(str),
					"scratch"::type(str),
					"id"::type(str),
					"label"::type(str),
					"constants"::{
						names: {
							pattern("^[A-Za-z][0-9A-Za-z_]*$"),
							length(null,64)
						},
						type(obj),
						properties[
							"class"::{
								enum["Constants"],
								type(str)
							},
							"version"::,
							"timestamp"::type(str),
							addp(
							|	class
							|	version
							|	timestamp)::if: {
								type(obj),
								req["protected",
									"ciphertext"]
							}, 
							then: {
								if: true, 
								then: ref: "#/$defs/JWE",
								properties[
									"allowReuse"::type(bool),
									addp(
									|	allowReuse)::false
								]
							}
						]
					},
					"class"::{
						enum["ADC"],
						type(str)
					},
					"target"::{
						type(obj),
						properties[
							"hostname"::type(str),
							"address"::type(str),
							"ssgName"::type(str)
						],
						pro(null,1)
					},
					"Common"::{
						type(obj),
						properties[
							"controls"::ref: "#/$defs/Controls",
							"enable"::{
								enum[true],
								type(bool)
							},
							"remark"::ref: "#/$defs/Remark",
							"label"::ref: "#/$defs/Label",
							"constants"::ref: "#/$defs/Constants",
							"Shared"::ref: "#/$defs/Application_Shared",
							"class"::{
								enum["Tenant"],
								type(str)
							},
							"verifiers"::type(obj),
							addp(
							|	controls
							|	enable
							|	remark
							|	label
							|	constants
							|	Shared
							|	class
							|	verifiers)::false
						]
					},
					addp(
					|	schemaVersion
					|	controls
					|	updateMode
					|	remark
					|	scratch
					|	id
					|	label
					|	constants
					|	class
					|	target
					|	Common)::ref: "#/$defs/Tenant"
				],
				req["class",
					"schemaVersion",
					"id"]
			}
		]
	},
	def "Application_Shared" = {
		if: true, 
		then: ref: "#/definitions/Application",
		type(obj),
		properties[
			"template"::{
				const("[shared]"),
				type(str)
			},
			"enable"::{
				const([true]),
				type(bool)
			},
			"class"::{
				const("[Application]"),
				type(str)
			}
		],
		req["class",
			"template"]
	},
	def "GSLB_Pool_A" = ref: "#/definitions/GSLB_Pool",
	def "DOS_Profile_Application_Detection_Site" = {
		type(obj),
		properties[
			"minimumTps"::{
				bet(0,4294967295),
				type(int)
			},
			"maximumTps"::{
				bet(0,4294967295),
				type(int)
			},
			"minimumAutoTps"::{
				bet(0,4294967295),
				type(int)
			},
			"clientSideDefenseEnabled"::type(bool),
			"tpsIncreaseRate"::{
				bet(0,4294967295),
				type(int)
			},
			"captchaChallengeEnabled"::type(bool),
			"rateLimitingEnabled"::type(bool),
			"maximumAutoTps"::{
				bet(0,4294967295),
				type(int)
			},
			addp(
			|	minimumTps
			|	maximumTps
			|	minimumAutoTps
			|	clientSideDefenseEnabled
			|	tpsIncreaseRate
			|	captchaChallengeEnabled
			|	rateLimitingEnabled
			|	maximumAutoTps)::false
		]
	},
	def "Pointer_Persist" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Firewall_Rule" = {
		type(obj),
		properties[
			"protocol"::{
				type(str),
				enum["any", "tcp", "udp"]
			},
			"loggingEnabled"::type(bool),
			"name"::type(str),
			"destination"::ref: "#/definitions/Firewall_Rule_Destination",
			"action"::{
				type(str),
				enum["accept", "drop", "accept-decisively", "reject"]
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"source"::ref: "#/definitions/Firewall_Rule_Source",
			"iRule"::{
				type(obj),
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					},
					addp(
					|	bigip
					|	use)::false
				],
				pro(1,1)
			},
			"iRuleSampleRate"::type(int),
			addp(
			|	protocol
			|	loggingEnabled
			|	name
			|	destination
			|	action
			|	remark
			|	label
			|	source
			|	iRule
			|	iRuleSampleRate)::false
		],
		req["name",
			"action"]
	},
	def "Policy_Condition_HTTP_Header" = {
		allOf[
			properties[
				"event"::{
					type(str),
					enum["proxy-request", "request", "proxy-connect", "proxy-response", "response"]
				}
			],
			{
				properties[
					"all"::ref: "#/definitions/Policy_Compare_String",
					"name"::type(str)
				],
				req["all",
					"name"]
			}
		],
		type(obj)
	},
	def "Pointer_SSH_Proxy_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "DOS_Profile_Application" = {
		type(obj),
		properties[
			"captchaResponse"::ref: "#/definitions/DOS_Profile_Application_Captcha",
			"mobileDefense"::ref: "#/definitions/DOS_Profile_Application_Mobile_Defense",
			"remoteTriggeredBlackHoleDuration"::{
				bet(0,4294967295),
				type(int)
			},
			"singlePageApplicationEnabled"::type(bool),
			"botDefense"::ref: "#/definitions/DOS_Profile_Application_Bot_Defense",
			"triggerIRule"::type(bool),
			"profileAcceleration"::ref: "#/definitions/Pointer_L4_Profile",
			"recordTraffic"::ref: "#/definitions/DOS_Profile_Application_TCP_Dump",
			"rateBasedDetection"::ref: "#/definitions/DOS_Profile_Application_Rate_Based_Detection",
			"whitelistedGeolocations"::{
				type(arr),
				items(;type(str))
			},
			"scrubbingDuration"::{
				bet(0,4294967295),
				type(int)
			},
			"botSignatures"::ref: "#/definitions/DOS_Profile_Application_Bot_Signatures",
			"heavyURLProtection"::ref: "#/definitions/DOS_Profile_Application_Heavy_URL",
			"blacklistedGeolocations"::{
				type(arr),
				items(;type(str))
			},
			"stressBasedDetection"::ref: "#/definitions/DOS_Profile_Application_Stress_Based_Detection",
			addp(
			|	captchaResponse
			|	mobileDefense
			|	remoteTriggeredBlackHoleDuration
			|	singlePageApplicationEnabled
			|	botDefense
			|	triggerIRule
			|	profileAcceleration
			|	recordTraffic
			|	rateBasedDetection
			|	whitelistedGeolocations
			|	scrubbingDuration
			|	botSignatures
			|	heavyURLProtection
			|	blacklistedGeolocations
			|	stressBasedDetection)::false
		]
	},
	def "GSLB_Pool" = {
		allOf[
			if: properties[
				"resourceRecordType"::const("[MX]")
			], 
			then: properties[
				"maxAnswersReturned"::{
					bet(1,500),
					type(int)
				},
				"members"::{
					type(arr),
					items(;ref: "#/definitions/GSLB_Pool_Member_MX")
				}
			],
			if: properties[
				"resourceRecordType"::const("[CNAME]")
			], 
			then: allOf[
				properties[
					"members"::{
						type(arr),
						items(;ref: "#/definitions/GSLB_Pool_Member_CNAME")
					}
				],
				not: req["maxAnswersReturned",
					"monitors"]
			],
			if: properties[
				"resourceRecordType"::const("[A]")
			], 
			then: properties[
				"maxAnswersReturned"::{
					bet(1,500),
					type(int)
				},
				"members"::{
					type(arr),
					items(;ref: "#/definitions/GSLB_Pool_Member_A")
				}
			],
			if: properties[
				"resourceRecordType"::const("[AAAA]")
			], 
			then: properties[
				"maxAnswersReturned"::{
					bet(1,500),
					type(int)
				},
				"members"::{
					type(arr),
					items(;ref: "#/definitions/GSLB_Pool_Member_AAAA")
				}
			],
			if: anyOf[
				properties[
					"resourceRecordType"::const("[A]")
				],
				properties[
					"resourceRecordType"::const("[AAAA]")
				]
			], 
			then: properties[
				"connectionsLimitEnabled"::type(bool),
				"ppsLimit"::{
					bet(0,null),
					type(int)
				},
				"connectionsLimit"::{
					bet(0,null),
					type(int)
				},
				"fallbackIP"::type(str),
				"bpsLimit"::{
					bet(0,null),
					type(int)
				},
				"ppsLimitEnabled"::type(bool),
				"monitors"::{
					type(arr),
					items(;ref: "#/definitions/Pointer_GSLB_Monitor")
				},
				"bpsLimitEnabled"::type(bool)
			],
			if: anyOf[
				properties[
					"lbModePreferred"::const("[quality-of-service]")
				],
				properties[
					"lbModeFallback"::const("[quality-of-service]")
				]
			], 
			then: properties[
				"qosPacketRate"::{
					bet(0,null),
					type(int)
				},
				"qosHitRatio"::{
					bet(0,null),
					type(int)
				},
				"qosRoundTripTime"::{
					bet(0,null),
					type(int)
				},
				"qosVirtualServerScore"::{
					bet(0,null),
					type(int)
				},
				"qosTopology"::{
					bet(0,null),
					type(int)
				},
				"qosLinkCapacity"::{
					bet(0,null),
					type(int)
				},
				"qosKbps"::{
					bet(0,null),
					type(int)
				},
				"qosHops"::{
					bet(0,null),
					type(int)
				},
				"qosVirtualServerCapacity"::{
					bet(0,null),
					type(int)
				}
			]
		],
		type(obj),
		properties[
			"lbModePreferred"::{
				type(str),
				enum["completion-rate", "cpu", "drop-packet", "fallback-ip", "fewest-hops", "global-availability", "kilobytes-per-second", "least-connections", "lowest-round-trip-time", "packet-rate", "quality-of-service", "ratio", "return-to-dns", "round-robin", "static-persistence", "topology", "virtual-server-capacity", "virtual-server-score"]
			},
			"lbModeFallback"::{
				type(str),
				enum["completion-rate", "cpu", "drop-packet", "fallback-ip", "fewest-hops", "global-availability", "kilobytes-per-second", "least-connections", "lowest-round-trip-time", "packet-rate", "quality-of-service", "ratio", "return-to-dns", "round-robin", "static-persistence", "topology", "virtual-server-capacity", "virtual-server-score", "none"]
			},
			"resourceRecordType"::{
				type(str),
				enum["A", "AAAA", "CNAME", "MX"]
			},
			"manualResumeEnabled"::type(bool),
			"verifyMemberEnabled"::type(bool),
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[GSLB_Pool]"),
				type(str)
			},
			"lbModeAlternate"::{
				type(str),
				enum["drop-packet", "fallback-ip", "global-availability", "packet-rate", "ratio", "return-to-dns", "round-robin", "static-persistence", "topology", "virtual-server-capacity", "virtual-server-score", "none"]
			},
			"ttl"::{
				bet(0,4294967295),
				type(int)
			},
			"enabled"::type(bool)
		],
		req["class",
			"resourceRecordType"]
	},
	def "Secret" = {
		oneOf[
			req["ciphertext"],
			req["reuseFrom"],
			req["url"]
		],
		if: req["ciphertext"], 
		then: ref: "#/definitions/JWE",
		type(obj),
		properties[
			"allowReuse"::type(bool),
			"reuseFrom"::{
				length(1,null),
				type(str)
			},
			"url"::type(str)
		]
	},
	def "Pointer_Enforcement_Protocol_Profile_Radius" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "SSH_Proxy_Profile_Auth_Info_Collection" = {
		type(obj),
		properties[
			"name"::type(str),
			"proxyServerAuth"::ref: "#/definitions/SSH_Proxy_Profile_Proxy_Auth_Info",
			"realServerAuth"::ref: "#/definitions/SSH_Proxy_Profile_Real_Server_Auth_Info",
			"proxyClientAuth"::ref: "#/definitions/SSH_Proxy_Profile_Proxy_Auth_Info",
			addp(
			|	name
			|	proxyServerAuth
			|	realServerAuth
			|	proxyClientAuth)::false
		]
	},
	def "NAT_Policy" = {
		type(obj),
		properties[
			"remark"::ref: "#/definitions/Remark",
			"rules"::{
				type(arr),
				items(;ref: "#/definitions/NAT_Rule")
			},
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[NAT_Policy]"),
				type(str)
			},
			addp(
			|	remark
			|	rules
			|	label
			|	class)::false
		],
		req["class"]
	},
	def "GSLB_Domain_A" = ref: "#/definitions/GSLB_Domain",
	def "Pointer_Enforcement_Profile_Gx" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Enforcement_Format_Script" = {
		type(obj),
		properties[
			"remark"::ref: "#/definitions/Remark",
			"definition"::type(str),
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[Enforcement_Format_Script]"),
				type(str)
			},
			addp(
			|	remark
			|	definition
			|	label
			|	class)::false
		],
		req["class"]
	},
	def "Security_Log_Profile_Protocol_Dns_Dos" = properties[
		"publisher"::{
			type(obj),
			properties[
				"bigip"::type(str),
				"use"::{
					length(1,null),
					type(str)
				},
				addp(
				|	bigip
				|	use)::false
			],
			pro(1,1)
		},
		addp(
		|	publisher)::false
	],
	def "DNS_Zone" = {
		properties[
			"responsePolicyEnabled"::type(bool),
			"dnsExpress"::ref: "#/definitions/DNS_Zone_DNS_Express",
			"serverTsigKey"::ref: "#/definitions/Pointer_DNS_TSIG_Key",
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[DNS_Zone]"),
				type(str)
			},
			"transferClients"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_DNS_Nameserver")
			},
			addp(
			|	responsePolicyEnabled
			|	dnsExpress
			|	serverTsigKey
			|	remark
			|	label
			|	class
			|	transferClients)::false
		],
		req["class"]
	},
	def "Monitor_HTTPS" = {
		if: true, 
		then: ref: "#/definitions/Monitor_HTTP",
		properties[
			"clientTLS"::ref: "#/definitions/Pointer_TLS_Client",
			"clientCertificate"::{
				length(1,null),
				type(str)
			},
			"ciphers"::type(str)
		]
	},
	def "Service_Discovery_Polling_Core" = properties[
		"undetectableAction"::{
			type(str),
			enum["disable", "remove"]
		},
		"addressRealm"::{
			type(str),
			enum["public", "private"]
		},
		"credentialUpdate"::type(bool)
	],
	def "Pointer_GSLB_Server" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "DNS_Cache" = {
		if: properties[
			"type"::const("[transparent]")
		], 
		then: ref: "#/definitions/DNS_Cache_Transparent",
		type(obj),
		properties[
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"type"::{
				type(str),
				enum["transparent"]
			},
			"class"::{
				const("[DNS_Cache]"),
				type(str)
			}
		],
		req["class",
			"type"]
	},
	def "Monitor_RADIUS" = properties[
		"passphrase"::{
			if: true, 
			then: ref: "#/definitions/Secret",
			type(obj),
			properties[
				"allowReuse"::type(bool)
			]
		},
		"secret"::{
			if: true, 
			then: ref: "#/definitions/Secret",
			type(obj),
			properties[
				"allowReuse"::type(bool)
			]
		},
		"username"::type(str),
		"nasIpAddress"::type(str)
	],
	def "HTTP_Profile_Explicit" = {
		type(obj),
		properties[
			"truncatedRedirects"::type(bool),
			"resolver"::{
				type(obj),
				properties[
					"bigip"::type(str),
					addp(
					|	bigip)::false
				],
				req["bigip"]
			},
			"routeDomain"::{
				bet(0,65535),
				type(int)
			},
			"dnsErrorMessage"::{
				length(null,65279),
				type(str)
			},
			"badRequestMessage"::{
				length(null,65279),
				type(str)
			},
			"connectErrorMessage"::{
				length(null,65279),
				type(str)
			},
			"maxHeaderSize"::{
				bet(9,262144),
				type(int)
			},
			"maxHeaderCount"::{
				bet(1,1024),
				type(int)
			},
			"doNotProxyHosts"::{
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"ipv6"::type(bool),
			"defaultConnectAction"::{
				type(str),
				enum["deny", "allow"]
			},
			"badResponseMessage"::{
				length(null,65279),
				type(str)
			},
			"tunnelName"::{
				length(1,63),
				type(str)
			}
		]
	},
	def "DOS_DNS_Vector" = {
		type(obj),
		properties[
			"rateIncreaseThreshold"::{
				bet(0,4294967295),
				type(int)
			},
			"rateLimit"::{
				bet(0,4294967295),
				type(int)
			},
			"thresholdMode"::{
				type(str),
				enum["manual", "stress-based-mitigation", "fully-automatic"]
			},
			"autoAttackCeiling"::{
				bet(0,4294967295),
				type(int)
			},
			"badActorSettings"::ref: "#/definitions/DOS_Bad_Actor_Detection_Settings",
			"simulateAutoThresholdEnabled"::type(bool),
			"autoAttackFloor"::{
				bet(0,4294967295),
				type(int)
			},
			"state"::{
				type(str),
				enum["disabled", "learn-only", "detect-only", "mitigate"]
			},
			"type"::{
				type(str),
				enum["a", "aaaa", "any", "axfr", "cname", "ixfr", "mx", "ns", "other", "ptr", "soa", "srv", "txt", "malformed"]
			},
			"rateThreshold"::{
				bet(0,4294967295),
				type(int)
			},
			"autoBlacklistSettings"::ref: "#/definitions/DOS_Auto_Blacklist_Settings",
			addp(
			|	rateIncreaseThreshold
			|	rateLimit
			|	thresholdMode
			|	autoAttackCeiling
			|	badActorSettings
			|	simulateAutoThresholdEnabled
			|	autoAttackFloor
			|	state
			|	type
			|	rateThreshold
			|	autoBlacklistSettings)::false
		],
		req["type"]
	},
	def "Enforcement_Rule_DTOS_Tethering" = properties[
		"reportDestinationHsl"::ref: "#/definitions/Enforcement_Rule_Report_Destination_HSL",
		"detectTethering"::type(bool),
		"detectDtos"::type(bool),
		addp(
		|	reportDestinationHsl
		|	detectTethering
		|	detectDtos)::false
	],
	def "Pointer_Bandwidth_Control_Policy" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Service_Discovery_Consul" = {
		ref: "#/definitions/Service_Discovery_Polling_Core",
		if: req["monitors"], 
		then: properties[
			"minimumMonitors"::
		],
		properties[
			"rejectUnauthorized"::type(bool),
			"trustCA"::ref: "#/definitions/Pointer_CA_Bundle",
			"encodedToken"::oneOf[
				{
					length(1,null),
					type(str)
				},
				allOf[
					req["ciphertext"],
					ref: "#/definitions/Secret"
				]
			],
			"uri"::{
				length(1,null),
				type(str)
			}
		],
		req["uri"]
	},
	def "Tenant" = {
		names: {
			pattern("^[A-Za-z][0-9A-Za-z_]*$"),
			length(null,64)
		},
		type(obj),
		properties[
			"controls"::ref: "#/definitions/Controls",
			"optimisticLockKey"::{
				length(null,128),
				type(str)
			},
			"enable"::type(bool),
			"defaultRouteDomain"::{
				bet(0,65535),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"constants"::ref: "#/definitions/Constants",
			"Shared"::ref: "#/definitions/Application_Shared",
			"class"::{
				const("[Tenant]"),
				type(str)
			},
			"verifiers"::type(obj),
			addp(
			|	controls
			|	optimisticLockKey
			|	enable
			|	defaultRouteDomain
			|	remark
			|	label
			|	constants
			|	Shared
			|	class
			|	verifiers)::ref: "#/definitions/Application"
		],
		req["class"]
	},
	def "Pointer_GSLB_Pool" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Template_http" = {
		properties[
			"serviceMain"::ref: "#/definitions/Service_HTTP"
		],
		req["serviceMain"]
	},
	def "Monitor" = {
		if: properties[
			"monitorType"::const("[icmp]")
		], 
		then: ref: "#/definitions/Monitor_ICMP", 
		else: {
			if: properties[
				"monitorType"::const("[http]")
			], 
			then: ref: "#/definitions/Monitor_HTTP", 
			else: if: properties[
				"monitorType"::const("[https]")
			], 
			then: ref: "#/definitions/Monitor_HTTPS", 
			else: if: properties[
				"monitorType"::const("[external]")
			], 
			then: ref: "#/definitions/Monitor_External", 
			else: if: properties[
				"monitorType"::const("[tcp]")
			], 
			then: {
				if: true, 
				then: ref: "#/definitions/Monitor_Send_Recv",
				properties[
					"dscp"::{
						bet(0,63),
						type(int)
					}
				]
			}, 
			else: if: properties[
				"monitorType"::const("[udp]")
			], 
			then: ref: "#/definitions/Monitor_Send_Recv", 
			else: if: properties[
				"monitorType"::const("[smtp]")
			], 
			then: ref: "#/definitions/Monitor_SMTP", 
			else: if: properties[
				"monitorType"::const("[sip]")
			], 
			then: ref: "#/definitions/Monitor_SIP", 
			else: if: properties[
				"monitorType"::const("[tcp-half-open]")
			], 
			then: ref: "#/definitions/Monitor_TCP_Half_Open", 
			else: if: properties[
				"monitorType"::const("[ldap]")
			], 
			then: ref: "#/definitions/Monitor_LDAP", 
			else: if: properties[
				"monitorType"::const("[dns]")
			], 
			then: ref: "#/definitions/Monitor_DNS", 
			else: if: properties[
				"monitorType"::const("[radius]")
			], 
			then: ref: "#/definitions/Monitor_RADIUS", 
			else: if: properties[
				"monitorType"::const("[ftp]")
			], 
			then: ref: "#/definitions/Monitor_FTP", 
			else: {
				not: true
			},
			properties[
				"targetPort"::{
					bet(0,65535),
					type(int)
				}
			]
		},
		type(obj),
		properties[
			"monitorType"::{
				type(str),
				enum["dns", "external", "ftp", "http", "https", "icmp", "ldap", "radius", "sip", "smtp", "tcp", "tcp-half-open", "udp"]
			},
			"targetAddress"::type(str),
			"timeUntilUp"::{
				bet(0,1800),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"interval"::{
				bet(0,3600),
				type(int)
			},
			"label"::ref: "#/definitions/Label",
			"upInterval"::{
				bet(0,3600),
				type(int)
			},
			"class"::{
				const("[Monitor]"),
				type(str)
			},
			"timeout"::{
				bet(0,900),
				type(int)
			}
		],
		req["class",
			"monitorType"]
	},
	def "Pointer_GSLB_Domain_MX" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Security_Log_Profile_Nat_Storage_Format" = anyOf[
		{
			length(1,null),
			type(str)
		},
		{
			type(obj),
			properties[
				"delimiter"::type(str),
				"fields"::{
					type(arr),
					items(;{
						type(str),
						enum["context-name", "duration", "route-domain", "sub-id", "translated-dest-port", "translated-src-port", "dest-ip", "event-name", "src-ip", "timestamp", "translated-route-domain", "dest-port", "protocol", "src-port", "translated-dest-ip", "translated-src-ip"]
					})
				},
				addp(
				|	delimiter
				|	fields)::false
			],
			req["fields"]
		}
	],
	def "HTTP_Profile_Reverse" = {
		type(obj),
		properties[
			"truncatedRedirects"::type(bool),
			"maxHeaderCount"::{
				bet(1,1024),
				type(int)
			},
			"maxHeaderSize"::{
				bet(9,262144),
				type(int)
			}
		]
	},
	def "DOS_Profile_Application_TCP_Dump" = properties[
		"recordTrafficEnabled"::type(bool),
		"maximumDuration"::{
			bet(0,4294967295),
			type(int)
		},
		"repetitionInterval"::oneOf[
			{
				const("[once-per-attack]"),
				type(str)
			},
			{
				bet(0,4294967295),
				type(int)
			}
		],
		"maximumSize"::{
			bet(0,4294967295),
			type(int)
		},
		addp(
		|	recordTrafficEnabled
		|	maximumDuration
		|	repetitionInterval
		|	maximumSize)::false
	],
	def "Pointer_Classification_Category" = {
		type(obj),
		properties[
			"bigip"::type(str),
			addp(
			|	bigip)::false
		],
		pro(1,1)
	},
	def "Pointer_Firewall_Policy" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "DOS_Profile_Application_Mobile_Defense" = {
		type(obj),
		properties[
			"clientSideChallengeMode"::{
				type(str),
				enum["pass", "challenge"]
			},
			"allowEmulators"::type(bool),
			"allowAndroidPublishers"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_SSL_Certificate")
			},
			"allowIosPackageNames"::{
				type(arr),
				items(;type(str))
			},
			"allowAndroidRootedDevice"::type(bool),
			"enabled"::type(bool),
			"allowJailbrokenDevices"::type(bool),
			addp(
			|	clientSideChallengeMode
			|	allowEmulators
			|	allowAndroidPublishers
			|	allowIosPackageNames
			|	allowAndroidRootedDevice
			|	enabled
			|	allowJailbrokenDevices)::false
		]
	},
	def "Persist_SIP" = {
		properties[
			"duration"::{
				bet(0,604800),
				type(int)
			},
			"header"::{
				length(1,null),
				type(str)
			}
		],
		req["header"]
	},
	def "AS3_Patch_Body" = {
		betitems(1,null),
		type(arr),
		items(;ref: "#/definitions/AS3_Patch_Item")
	},
	def "Pointer_Radius_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_Pool" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Pointer_TLS_Client" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Endpoint_Strategy" = {
		type(obj),
		properties[
			"operands"::{
				type(arr),
				items(;type(str))
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"matchMethod"::{
				type(str),
				enum["all-match", "best-match", "first-match"]
			},
			"class"::{
				const("[Endpoint_Strategy]"),
				type(str)
			},
			addp(
			|	operands
			|	remark
			|	label
			|	matchMethod
			|	class)::false
		],
		req["class",
			"matchMethod"]
	},
	def "GSLB_Virtual_Server" = {
		properties[
			"addressTranslationPort"::{
				bet(0,65535),
				type(int)
			},
			"address"::type(str),
			"addressTranslation"::type(str),
			"port"::{
				bet(0,65535),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"enabled"::type(bool),
			"monitors"::{
				type(arr),
				items(;ref: "#/definitions/Pointer_GSLB_Monitor")
			}
		],
		req["address",
			"port"]
	},
	def "Template_l4" = {
		properties[
			"serviceMain"::ref: "#/definitions/Service_L4"
		],
		req["serviceMain"]
	},
	def "SSH_Proxy_Profile_Default_Action_Collection" = {
		type(obj),
		properties[
			"rexecAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"scpDownAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"shellAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"x11ForwardAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"agentAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"otherAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"localForwardAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"remoteForwardAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"scpUpAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"sftpUpAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"name"::type(str),
			"sftpDownAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			"subSystemAction"::ref: "#/definitions/SSH_Proxy_Profile_Default_Action",
			addp(
			|	rexecAction
			|	scpDownAction
			|	shellAction
			|	x11ForwardAction
			|	agentAction
			|	otherAction
			|	localForwardAction
			|	remoteForwardAction
			|	scpUpAction
			|	sftpUpAction
			|	name
			|	sftpDownAction
			|	subSystemAction)::false
		]
	},
	def "Data_Group_Records_IP" = allOf[
		ref: "#/definitions/Data_Group_Records_Base"
	],
	def "Pointer_Firewall_Address_List" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "DNS_Zone_Local" = {
		type(obj),
		properties[
			"records"::{
				type(arr),
				items(;type(str))
			},
			"type"::{
				type(str),
				enum["deny", "redirect", "refuse", "static", "transparent", "type-transparent"]
			}
		]
	},
	def "GSLB_Domain_CNAME" = ref: "#/definitions/GSLB_Domain",
	def "GSLB_Pool_Member_CNAME" = {
		type(obj),
		properties[
			"isDomainNameStatic"::type(bool),
			"domainName"::anyOf[
				type(str),
				ref: "#/definitions/Pointer_GSLB_Domain_A",
				ref: "#/definitions/Pointer_GSLB_Domain_AAAA",
				ref: "#/definitions/Pointer_GSLB_Domain_CNAME",
				ref: "#/definitions/Pointer_GSLB_Domain_MX"
			],
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"ratio"::{
				bet(0,65535),
				type(int)
			},
			addp(
			|	isDomainNameStatic
			|	domainName
			|	remark
			|	label
			|	ratio)::false
		],
		req["domainName",
			"ratio"]
	},
	def "Enforcement_Rule_Ran_Congestion" = properties[
		"reportDestinationHsl"::ref: "#/definitions/Enforcement_Rule_Report_Destination_HSL",
		"threshold"::{
			bet(0,2147483647),
			type(int)
		},
		addp(
		|	reportDestinationHsl
		|	threshold)::false
	],
	def "HTTP_Compress" = {
		type(obj),
		properties[
			"preferMethod"::{
				type(str),
				enum["gzip", "deflate"]
			},
			"selective"::type(bool),
			"uriExcludes"::{
				uniqueItems,
				type(arr),
				items(;{
					pattern("^[^\x00-\x1f\x7f-\xff]+$"),
					type(str)
				})
			},
			"gzipWindowSize"::{
				bet(1,128),
				type(int)
			},
			"varyHeader"::type(bool),
			"contentTypeIncludes"::{
				uniqueItems,
				type(arr),
				items(;{
					pattern("^[^\x00-\x1f\x22\x7f-\xff]+$"),
					type(str)
				})
			},
			"gzipLevel"::{
				bet(1,9),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"keepAcceptEncoding"::type(bool),
			"uriIncludes"::{
				uniqueItems,
				type(arr),
				items(;{
					pattern("^[^\x00-\x1f\x7f-\xff]+$"),
					type(str)
				})
			},
			"cpuSaverLow"::{
				bet(10,95),
				type(int)
			},
			"minimumSize"::{
				bet(128,131072),
				type(int)
			},
			"cpuSaver"::type(bool),
			"cpuSaverHigh"::{
				bet(15,99),
				type(int)
			},
			"contentTypeExcludes"::{
				uniqueItems,
				type(arr),
				items(;{
					pattern("^[^\x00-\x1f\x22\x7f-\xff]+$"),
					type(str)
				})
			},
			"class"::{
				const("[HTTP_Compress]"),
				type(str)
			},
			"gzipMemory"::{
				bet(1,256),
				type(int)
			},
			"allowHTTP10"::type(bool),
			"bufferSize"::{
				bet(256,32768),
				type(int)
			},
			addp(
			|	preferMethod
			|	selective
			|	uriExcludes
			|	gzipWindowSize
			|	varyHeader
			|	contentTypeIncludes
			|	gzipLevel
			|	remark
			|	label
			|	keepAcceptEncoding
			|	uriIncludes
			|	cpuSaverLow
			|	minimumSize
			|	cpuSaver
			|	cpuSaverHigh
			|	contentTypeExcludes
			|	class
			|	gzipMemory
			|	allowHTTP10
			|	bufferSize)::false
		],
		req["class"]
	},
	def "Enforcement_Radius_AAA_Profile" = {
		type(obj),
		properties[
			"password"::{
				if: true, 
				then: ref: "#/definitions/Secret",
				type(obj),
				properties[
					"allowReuse"::type(bool)
				]
			},
			"parentProfile"::ref: "#/definitions/Pointer_Enforcement_Radius_AAA_Profile",
			"transactionTimeout"::{
				bet(5,300),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"sharedSecret"::{
				if: true, 
				then: ref: "#/definitions/Secret",
				type(obj),
				properties[
					"allowReuse"::type(bool)
				]
			},
			"class"::{
				const("[Enforcement_Radius_AAA_Profile]"),
				type(str)
			},
			"retransmissionTimeout"::{
				bet(0,60),
				type(int)
			},
			addp(
			|	password
			|	parentProfile
			|	transactionTimeout
			|	remark
			|	label
			|	sharedSecret
			|	class
			|	retransmissionTimeout)::false
		],
		req["class"]
	},
	def "Rewrite_Profile_Request_Settings" = {
		type(obj),
		properties[
			"insertXforwardedForEnabled"::type(bool),
			"rewriteHeadersEnabled"::type(bool),
			"insertXforwardedProtoEnabled"::type(bool),
			"insertXforwardedHostEnabled"::type(bool),
			addp(
			|	insertXforwardedForEnabled
			|	rewriteHeadersEnabled
			|	insertXforwardedProtoEnabled
			|	insertXforwardedHostEnabled)::false
		]
	},
	def "Security_Log_Profile_Nat" = {
		properties[
			"rateLimitErrors"::type(int),
			"formatQuotaExceeded"::ref: "#/definitions/Security_Log_Profile_Nat_Storage_Format",
			"rateLimitQuotaExceeded"::type(int),
			"logEndInboundSession"::type(bool),
			"logStartInboundSession"::type(bool),
			"formatEndInboundSession"::ref: "#/definitions/Security_Log_Profile_Nat_Storage_Format",
			"rateLimitAggregate"::type(int),
			"formatErrors"::ref: "#/definitions/Security_Log_Profile_Nat_Storage_Format",
			"rateLimitStartInboundSession"::type(int),
			"formatStartOutboundSession"::ref: "#/definitions/Security_Log_Profile_Nat_Storage_Format",
			"logSubscriberId"::type(bool),
			"formatEndOutboundSession"::ref: "#/definitions/Security_Log_Profile_Nat_Storage_Format",
			"logEndOutboundSession"::type(bool),
			"logErrors"::type(bool),
			"rateLimitEndInboundSession"::type(int),
			"formatStartInboundSession"::ref: "#/definitions/Security_Log_Profile_Nat_Storage_Format",
			"rateLimitStartOutboundSession"::type(int),
			"publisher"::{
				type(obj),
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					},
					addp(
					|	bigip
					|	use)::false
				],
				pro(1,1)
			},
			"rateLimitEndOutboundSession"::type(int),
			"logQuotaExceeded"::type(bool),
			"logStartOutboundSession"::type(bool),
			addp(
			|	rateLimitErrors
			|	formatQuotaExceeded
			|	rateLimitQuotaExceeded
			|	logEndInboundSession
			|	logStartInboundSession
			|	formatEndInboundSession
			|	rateLimitAggregate
			|	formatErrors
			|	rateLimitStartInboundSession
			|	formatStartOutboundSession
			|	logSubscriberId
			|	formatEndOutboundSession
			|	logEndOutboundSession
			|	logErrors
			|	rateLimitEndInboundSession
			|	formatStartInboundSession
			|	rateLimitStartOutboundSession
			|	publisher
			|	rateLimitEndOutboundSession
			|	logQuotaExceeded
			|	logStartOutboundSession)::false
		],
		req["publisher"]
	},
	def "SNAT_Pool" = {
		type(obj),
		properties[
			"snatAddresses"::{
				betitems(1,null),
				uniqueItems,
				type(arr),
				items(;type(str))
			},
			"remark"::ref: "#/definitions/Remark",
			"label"::ref: "#/definitions/Label",
			"class"::{
				const("[SNAT_Pool]"),
				type(str)
			},
			addp(
			|	snatAddresses
			|	remark
			|	label
			|	class)::false
		],
		req["class",
			"snatAddresses"]
	},
	def "Log_Destination_Remote_Syslog" = {
		type(obj),
		properties[
			"defaultFacility"::{
				type(str),
				enum["local0", "local1", "local2", "local3", "local4", "local5", "local6", "local7"]
			},
			"format"::{
				type(str),
				enum["legacy-bigip", "rfc3164", "rfc5424"]
			},
			"defaultSeverity"::{
				type(str),
				enum["alert", "crit", "debug", "emerg", "err", "info", "notice", "warn"]
			},
			"remoteHighSpeedLog"::{
				type(obj),
				properties[
					"bigip"::type(str),
					"use"::{
						length(1,null),
						type(str)
					},
					addp(
					|	bigip
					|	use)::false
				],
				pro(1,1)
			}
		],
		req["remoteHighSpeedLog"]
	},
	def "Policy_Action_WAF" = {
		type(obj),
		properties[
			"event"::{
				type(str),
				enum["client-accepted", "proxy-request", "request"]
			},
			"policy"::ref: "#/definitions/Pointer_WAF_Policy"
		]
	},
	def "Pointer_CA_Bundle" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "TCP_Profile" = {
		type(obj),
		properties[
			"autoReceiveWindowSize"::type(bool),
			"ratePaceMaxRate"::{
				bet(0,4294967295),
				type(int)
			},
			"slowStart"::type(bool),
			"ttlIPv4"::{
				bet(1,255),
				type(int)
			},
			"fastOpenCookieExpiration"::{
				bet(1,1000000),
				type(int)
			},
			"congestionMetricsCacheTimeout"::{
				bet(0,1000),
				type(int)
			},
			"ttlIPv6"::{
				bet(1,255),
				type(int)
			},
			"verifiedAccept"::type(bool),
			"deferredAccept"::type(bool),
			"ecn"::type(bool),
			"initRwnd"::{
				bet(0,64),
				type(int)
			},
			"synCookieWhitelist"::type(bool),
			"synCookieEnable"::type(bool),
			"mptcpCsumVerify"::type(bool),
			"maxRetrans"::{
				bet(0,12),
				type(int)
			},
			"initCwnd"::{
				bet(0,64),
				type(int)
			},
			"autoProxyBufferSize"::type(bool),
			"congestionControl"::{
				type(str),
				enum["cdg", "chd", "cubic", "high-speed", "illinois", "new-reno", "none", "reno", "scalable", "vegas", "westwood", "woodside"]
			},
			"maxSegmentSize"::{
				anyOf[
					bet(28,8960),
					const([0])
				],
				type(int)
			},
			"mptcpFastJoin"::type(bool),
			"delayWindowControl"::type(bool),
			"dsack"::type(bool),
			"enhancedLossRecovery"::type(bool),
			"ipDfMode"::{
				type(str),
				enum["clear", "pmtu", "preserve", "set"]
			},
			"md5SignaturePassphrase"::{
				if: true, 
				then: ref: "#/definitions/Secret",
				type(obj),
				properties[
					"allowReuse"::type(bool)
				]
			},
			"mptcpSubflowMax"::{
				bet(1,20),
				type(int)
			},
			"mptcpIdleTimeout"::{
				bet(1,86400),
				type(int)
			},
			"closeWaitTimeout"::{
				bet(-1,3600),
				type(int)
			},
			"congestionMetricsCache"::type(bool),
			"ipTosToClient"::oneOf[
				{
					mof(4),
					bet(0,252),
					type(int)
				},
				{
					type(str),
					enum["pass-through", "mimic"]
				}
			],
			"selectiveNack"::type(bool),
			"mptcpMakeAfterBreak"::type(bool),
			"mptcpCsum"::type(bool),
			"nagle"::{
				type(str),
				enum["disable", "enable", "auto"]
			},
			"linkQosToClient"::oneOf[
				{
					bet(0,7),
					type(int)
				},
				{
					const("[pass-through]"),
					type(str)
				}
			],
			"ratePace"::type(bool),
			"mptcpNoJoinDssAck"::type(bool),
			"pktLossIgnoreRate"::{
				bet(0,1000000),
				type(int)
			},
			"ackOnPush"::type(bool),
			"autoSendBufferSize"::type(bool),
			"timestamps"::type(bool),
			"delayedAcks"::type(bool),
			"md5Signature"::type(bool),
			"proxyBufferLow"::{
				bet(64,33554432),
				type(int)
			},
			"remark"::ref: "#/definitions/Remark",
			"proxyBufferHigh"::{
				bet(64,33554432),
				type(int)
			},
			"timeWaitTimeout"::{
				bet(-1,600000),
				type(int)
			},
			"limitedTransmit"::type(bool),
			"finWait2Timeout"::{
				bet(-1,3600),
				type(int)
			},
			"mptcpFallback"::{
				type(str),
				enum["accept", "active-accept", "reset", "retransmit"]
			},
			"minimumRto"::{
				bet(1,5000),
				type(int)
			},
			"mptcpRetransmitMin"::{
				bet(1,5000),
				type(int)
			},
			"selectiveAcks"::type(bool),
			"pktLossIgnoreBurst"::{
				bet(0,32),
				type(int)
			},
			"class"::{
				const("[TCP_Profile]"),
				type(str)
			},
			"finWaitTimeout"::{
				bet(-1,3600),
				type(int)
			},
			"mptcpRtoMax"::{
				bet(1,20),
				type(int)
			},
			"abc"::type(bool),
			"synMaxRetrans"::{
				bet(0,12),
				type(int)
			},
			"sendBufferSize"::{
				bet(64,33554432),
				type(int)
			},
			"receiveWindowSize"::{
				bet(64,33554432),
				type(int)
			},
			"mptcp"::{
				type(str),
				enum["disable", "enable", "passthrough"]
			},
			"label"::ref: "#/definitions/Label",
			"tailLossProbe"::type(bool),
			"keepAliveInterval"::{
				bet(1,86400),
				type(int)
			},
			"zeroWindowTimeout"::{
				bet(-1,86400000),
				type(int)
			},
			"synRtoBase"::{
				bet(0,5000),
				type(int)
			},
			"pushFlag"::{
				type(str),
				enum["auto", "default", "none", "one"]
			},
			"ttlMode"::{
				type(str),
				enum["decrement", "preserve", "proxy", "set"]
			},
			"idleTimeout"::{
				anyOf[
					bet(1,86400),
					const([-1])
				],
				type(int)
			},
			"mptcpTimeout"::{
				bet(60,3600),
				type(int)
			},
			"proxyMSS"::type(bool),
			"resetOnTimeout"::type(bool),
			"mptcpJoinMax"::{
				bet(1,20),
				type(int)
			},
			"proxyOptions"::type(bool),
			"earlyRetransmit"::type(bool),
			"retransmitThreshold"::{
				bet(0,12),
				type(int)
			},
			"tcpOptions"::{
				betitems(null,255),
				type(arr),
				items(;{
					type(obj),
					properties[
						"when"::{
							type(str),
							enum["first", "last"]
						},
						"option"::{
							bet(0,255),
							type(int)
						},
						addp(
						|	when
						|	option)::false
					]
				})
			},
			"fastOpen"::type(bool),
			"timeWaitRecycle"::type(bool),
			addp(
			|	autoReceiveWindowSize
			|	ratePaceMaxRate
			|	slowStart
			|	ttlIPv4
			|	fastOpenCookieExpiration
			|	congestionMetricsCacheTimeout
			|	ttlIPv6
			|	verifiedAccept
			|	deferredAccept
			|	ecn
			|	initRwnd
			|	synCookieWhitelist
			|	synCookieEnable
			|	mptcpCsumVerify
			|	maxRetrans
			|	initCwnd
			|	autoProxyBufferSize
			|	congestionControl
			|	maxSegmentSize
			|	mptcpFastJoin
			|	delayWindowControl
			|	dsack
			|	enhancedLossRecovery
			|	ipDfMode
			|	md5SignaturePassphrase
			|	mptcpSubflowMax
			|	mptcpIdleTimeout
			|	closeWaitTimeout
			|	congestionMetricsCache
			|	ipTosToClient
			|	selectiveNack
			|	mptcpMakeAfterBreak
			|	mptcpCsum
			|	nagle
			|	linkQosToClient
			|	ratePace
			|	mptcpNoJoinDssAck
			|	pktLossIgnoreRate
			|	ackOnPush
			|	autoSendBufferSize
			|	timestamps
			|	delayedAcks
			|	md5Signature
			|	proxyBufferLow
			|	remark
			|	proxyBufferHigh
			|	timeWaitTimeout
			|	limitedTransmit
			|	finWait2Timeout
			|	mptcpFallback
			|	minimumRto
			|	mptcpRetransmitMin
			|	selectiveAcks
			|	pktLossIgnoreBurst
			|	class
			|	finWaitTimeout
			|	mptcpRtoMax
			|	abc
			|	synMaxRetrans
			|	sendBufferSize
			|	receiveWindowSize
			|	mptcp
			|	label
			|	tailLossProbe
			|	keepAliveInterval
			|	zeroWindowTimeout
			|	synRtoBase
			|	pushFlag
			|	ttlMode
			|	idleTimeout
			|	mptcpTimeout
			|	proxyMSS
			|	resetOnTimeout
			|	mptcpJoinMax
			|	proxyOptions
			|	earlyRetransmit
			|	retransmitThreshold
			|	tcpOptions
			|	fastOpen
			|	timeWaitRecycle)::false
		],
		req["class"]
	},
	def "DOS_Network_Vector" = {
		type(obj),
		properties[
			"rateIncreaseThreshold"::{
				bet(0,4294967295),
				type(int)
			},
			"rateLimit"::{
				bet(0,4294967295),
				type(int)
			},
			"thresholdMode"::{
				type(str),
				enum["manual", "stress-based-mitigation", "fully-automatic"]
			},
			"autoAttackCeiling"::{
				bet(0,4294967295),
				type(int)
			},
			"badActorSettings"::ref: "#/definitions/DOS_Bad_Actor_Detection_Settings",
			"simulateAutoThresholdEnabled"::type(bool),
			"autoAttackFloor"::{
				bet(0,4294967295),
				type(int)
			},
			"state"::{
				type(str),
				enum["disabled", "learn-only", "detect-only", "mitigate"]
			},
			"type"::{
				type(str),
				enum["ext-hdr-too-large", "hop-cnt-low", "host-unreachable", "icmpv4-flood", "icmpv6-flood", "icmp-frag", "ip-frag-flood", "ip-opt-frames", "ipv6-ext-hdr-frames", "ipv6-frag-flood", "opt-present-with-illegal-len", "sweep", "tcp-half-open", "tcp-opt-overruns-tcp-hdr", "tcp-psh-flood", "tcp-rst-flood", "tcp-syn-flood", "tcp-synack-flood", "tcp-syn-oversize", "tcp-bad-urg", "tcp-window-size", "tidcmp", "too-many-ext-hdrs", "udp-flood", "unk-tcp-opt-type"]
			},
			"rateThreshold"::{
				bet(0,4294967295),
				type(int)
			},
			"autoBlacklistSettings"::ref: "#/definitions/DOS_Auto_Blacklist_Settings",
			addp(
			|	rateIncreaseThreshold
			|	rateLimit
			|	thresholdMode
			|	autoAttackCeiling
			|	badActorSettings
			|	simulateAutoThresholdEnabled
			|	autoAttackFloor
			|	state
			|	type
			|	rateThreshold
			|	autoBlacklistSettings)::false
		]
	},
	def "Pointer_Analytics_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "Enforcement_Rule_Forwarding_Endpoint" = {
		properties[
			"endpoint"::ref: "#/definitions/Pointer_Enforcement_Forwarding_Endpoint"
		],
		req["endpoint"]
	},
	def "Template_https" = {
		properties[
			"serviceMain"::ref: "#/definitions/Service_HTTPS"
		],
		req["serviceMain"]
	},
	def "Policy_Action_Forward" = {
		allOf[
			properties[
				"event"::{
					type(str),
					enum["ssl-client-hello", "request"]
				}
			],
			{
				properties[
					"select"::ref: "#/definitions/Policy_Action_Forward_Select"
				],
				req["select"]
			}
		],
		type(obj)
	},
	def "Pointer_UDP_Profile" = {
		type(obj),
		properties[
			"bigip"::type(str),
			"use"::{
				length(1,null),
				type(str)
			},
			addp(
			|	bigip
			|	use)::false
		],
		pro(1,1)
	},
	def "HTTP_Acceleration_Profile" = {
		type(obj),
		properties[
			"agingRate"::{
				bet(0,10),
				type(int)
			},
			"cacheSize"::{
				bet(0,4294967295),
				type(int)
			},
			"uriIncludeList"::{
				type(arr),
				items(;{
					length(1,null),
					type(str)
				})
			},
			"minimumObjectSize"::{
				bet(0,4294967295),
				type(int)
			},
			"uriExcludeList"::{
				type(arr),
				items(;{
					length(1,null),
					type(str)
				})
			},
			"label"::ref: "#/definitions/Label",
			"maximumObjectSize"::{
				bet(0,4294967295),
				type(int)
			},
			"maximumAge"::{
				bet(0,4294967295),
				type(int)
			},
			"ignoreHeaders"::{
				type(str),
				enum["all", "max-age", "none"]
			},
			"parentProfile"::ref: "#/definitions/Pointer_HTTP_Acceleration_Profile",
			"uriIncludeOverrideList"::{
				type(arr),
				items(;{
					length(1,null),
					type(str)
				})
			},
			"metadataMaxSize"::{
				bet(0,4294967295),
				type(int)
			},
			"insertAgeHeaderEnabled"::type(bool),
			"class"::{
				const("[HTTP_Acceleration_Profile]"),
				type(str)
			},
			"maximumEntries"::{
				bet(0,4294967295),
				type(int)
			},
			"uriPinnedList"::{
				type(arr),
				items(;{
					length(1,null),
					type(str)
				})
			},
			addp(
			|	agingRate
			|	cacheSize
			|	uriIncludeList
			|	minimumObjectSize
			|	uriExcludeList
			|	label
			|	maximumObjectSize
			|	maximumAge
			|	ignoreHeaders
			|	parentProfile
			|	uriIncludeOverrideList
			|	metadataMaxSize
			|	insertAgeHeaderEnabled
			|	class
			|	maximumEntries
			|	uriPinnedList)::false
		],
		req["class"]
	},
	def "Enum_Country_Code_Alpha_2" = {
		type(str),
		enum["--", "A1", "A2", "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AP", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "EU", "FI", "FJ", "FK", "FM", "FO", "FR", "FX", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "O1", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "ST", "SV", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]
	}
}
